{"ID":"20230927181627-jab9mvu","Spec":"2","Type":"NodeDocument","Properties":{"id":"20230927181627-jab9mvu","scroll":"\u0026#123;\u0026quot;rootId\u0026quot;:\u0026quot;20230927181627-dirymqv\u0026quot;,\u0026quot;startId\u0026quot;:\u0026quot;20231009180050-k6cgdj6\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20231110182939-q8jr0na\u0026quot;,\u0026quot;scrollTop\u0026quot;:138,\u0026quot;focusId\u0026quot;:\u0026quot;20231009180050-k6cgdj6\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0\u0026#125;","title":"Unity 自定义日志类","type":"doc","updated":"20231115151016"},"Children":[{"ID":"20231009180050-5lfch8v","Type":"NodeParagraph","Properties":{"id":"20231009180050-5lfch8v","updated":"20231009182948"},"Children":[{"Type":"NodeText","Data":"大量的输出对性能消耗较大，因此在正式版中应当屏蔽。使用自定义日志类可以控制在开发期间才输出Log，也可以设置Log的输出位置，将Log信息上传到服务器等操作。"}]},{"ID":"20231008212914-2tywdhy","Type":"NodeParagraph","Properties":{"id":"20231008212914-2tywdhy","updated":"20231008213105"},"Children":[{"Type":"NodeText","Data":"Unity.Debug消耗性能较大，在正式版中需要屏蔽。此外，使用自定义日志可以设置信息的输出路径、自定义输出信息、将信息发送到服务器等操作。"}]},{"ID":"20230927181627-i3vlfmn","Type":"NodeParagraph","Properties":{"id":"20230927181627-i3vlfmn","updated":"20231008203300"},"Children":[{"Type":"NodeText","Data":"Debug.Log占用的性能较多，在正式版中应当屏蔽。此外，使用自定义日志也可以输出信息到指定的路径，添加自定义信息或上传信息到服务器等。"}]},{"ID":"20231008203300-n4sc6og","Type":"NodeParagraph","Properties":{"id":"20231008203300-n4sc6og"}},{"ID":"20231008203355-zkjbh1k","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231008203355-zkjbh1k","updated":"20231106210641"},"Children":[{"Type":"NodeText","Data":"简单方法——使用UnityAPI实现"}]},{"ID":"20231008203405-myucus5","Type":"NodeParagraph","Properties":{"id":"20231008203405-myucus5","updated":"20231008204352"},"Children":[{"Type":"NodeText","Data":"继承ILogHandler接口，实现后即可替换默认的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Debug.unityLogger.logHandler"},{"Type":"NodeText","Data":"​。该接口需要实现"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LogException"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LogFormat"},{"Type":"NodeText","Data":"​方法。之后最好再通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FileLogTool"},{"Type":"NodeText","Data":"​静态方法来调用，方便使用。下方示例将Log输出到了文本文件中。"}]},{"ID":"20231008203030-j2ubdv2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"fold":"0","id":"20231008203030-j2ubdv2","style":"line-height: 22px;","updated":"20231009182504"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"    /// \u003csummary\u003e\n    /// 使用文件日志Handler，会将日志信息写到指定文件中\n    /// \u003c/summary\u003e\n    /// 相当于将Debug.unityLogger.logHandler添加了StreamWriter和FileStream后再封装\n    public class FileLogHandler : ILogHandler\n    {\n        //C:/Users/1223/AppData/LocalLow/DefaultCompany/xg_Test/MyLogs.txt\n        private string m_FilePath = Application.persistentDataPath + \"/MyLogs.txt\";\n\n        private ILogHandler m_LogHandler = Debug.unityLogger.logHandler;\n        private StreamWriter m_FileWriter;\n\n\n        /// \u003csummary\u003e\n        /// 构造，初始化FileStream和StreamWriter\n        /// \u003c/summary\u003e\n        public FileLogHandler()\n        {\n            m_FileWriter = new StreamWriter(m_FilePath, true, System.Text.Encoding.UTF8);\n\n            //执行后，m_LogHandler = 原来的UnityLogger，Debug.unityLogger.logHandler = FileLogHandler。\n            //那么再调用Debug.unityLogger.logHandler的时候就等同于是调用原来的UnityLogger的再封装，即FileLogHandler\n            Debug.unityLogger.logHandler = this;\n\n            Application.logMessageReceived += LogCallback;\n            AppDomain.CurrentDomain.UnhandledException += OnUnresolvedExceptionHandler;\n        }\n\n\n        public void LogException(Exception exception, UnityEngine.Object context)\n        {\n            //这里的m_LogHandler指向原来的Debug.unityLogger.logHandler，和UnityDebug等同\n            m_LogHandler.LogException(exception, context);\n        }\n\n\n        public void LogFormat(LogType logType, UnityEngine.Object context, string format, params object[] args)\n        {\n            m_FileWriter.WriteLine(CurrentTime() + \"\\r\\n\" + String.Format(format, args));\n            //不等待之后的写入，先将数据放到文件中\n            m_FileWriter.Flush();\n            //这里的m_LogHandler指向原来的Debug.unityLogger.logHandler，和UnityDebug等同\n            m_LogHandler.LogFormat(logType, context, format, args);\n        }\n\n\n        /// \u003csummary\u003e\n        /// condition为日志信息，stackTrace为堆栈跟踪，type为日志类型\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"condition\"\u003e\u003c/param\u003e\n        /// \u003cparam name=\"stackTrace\"\u003e\u003c/param\u003e\n        /// \u003cparam name=\"type\"\u003e\u003c/param\u003e\n        /// 此方法只有在主线程中才会被触发，如果需要访问在主线程中受限的API，则使用它。\n        private void LogCallback(string condition, string stackTrace, LogType type)\n        {\n            m_FileWriter.Write(\n                CurrentTime()\n                + \"\\r\\n日志信息：\\r\\n\"\n                + condition\n                + \"\\r\\n堆栈跟踪：\\r\\n\"\n                + stackTrace\n                + \"--------------------------------------------------------------------------------------------\\r\\n\");\n            m_FileWriter.Flush();\n        }\n\n\n        /// \u003csummary\u003e\n        /// 可以捕获Unity无法捕获的异常\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"sender\"\u003e\u003c/param\u003e\n        /// \u003cparam name=\"e\"\u003e\u003c/param\u003e\n        /// \u003cexception cref=\"NotImplementedException\"\u003e\u003c/exception\u003e\n        private void OnUnresolvedExceptionHandler(object sender, UnhandledExceptionEventArgs e)\n        {\n            throw new NotImplementedException();\n        }\n\n\n        private string CurrentTime()\n        {\n            return System.DateTime.Now.ToString();\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// 输出日志到文件中\n    /// \u003c/summary\u003e\n    public static class FileLogTool\n    {\n        private static FileLogHandler m_FileLogHandler = new FileLogHandler();\n\n        //使用这个特性可以用宏定义来控制是否编译为中间语言，用于方法时，只能用于返回值为void的方法。\n        //在unity的文件中使用#define不起作用。在ProjectSetting-》Player-》OtherSettings-》ScriptingDefineSymbols中设置即可\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void Log(string msg)\n        {\n            m_FileLogHandler.LogFormat(LogType.Log, null, msg);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogFormat(string msg, params object[] args)\n        {\n            m_FileLogHandler.LogFormat(LogType.Log, null, msg, args);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogException(Exception exception, UnityEngine.Object content)\n        {\n            m_FileLogHandler.LogException(exception, content);\n        }\n    }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231009182510-exi6817","Type":"NodeParagraph","Properties":{"id":"20231009182510-exi6817"}},{"ID":"20231009185318-64jmswh","Type":"NodeParagraph","Properties":{"id":"20231009185318-64jmswh","updated":"20231009185339"},"Children":[{"Type":"NodeText","Data":"正常输出到Unity的简单方法"}]},{"ID":"20231009182751-b94buca","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"fold":"1","id":"20231009182751-b94buca","style":"line-height: 22px;","updated":"20231009185309"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"    public class CustomLogHandler : ILogHandler\n    {\n        private ILogHandler m_LogHandler = Debug.unityLogger.logHandler;\n\n\n        public CustomLogHandler() { }\n\n\n        public void LogException(Exception exception, UnityEngine.Object context)\n        {\n            m_LogHandler.LogException(exception, context);\n        }\n\n\n        public void LogFormat(LogType logType, UnityEngine.Object context, string format, params object[] args)\n        {\n            m_LogHandler.LogFormat(logType, context, format, args);\n        }\n    }\n\n\n    /// \u003csummary\u003e\n    /// 只有常用的log，有需要再添加对应的重载方法\n    /// \u003c/summary\u003e\n    public static class LogTool\n    {\n        private static Logger m_Logger = new Logger(new CustomLogHandler());\n\n        //也可以写个开关控制是否输出，也可以使用这种方式。这种方式若条件不满足，不会被编译成中间语言\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void Log(object message)\n        {\n            m_Logger.Log(message);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogFormat(string format, params object[] args)\n        {\n            m_Logger.LogFormat(LogType.Log, format, args);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogWarning(string format, params object[] args)\n        {\n            m_Logger.LogFormat(LogType.Warning, format, args);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogError(string format, params object[] args)\n        {\n            m_Logger.LogFormat(LogType.Error, format, args);\n        }\n\n\n        [System.Diagnostics.Conditional(\"Develop_Log\")]\n        public static void LogException(Exception exception)\n        {\n            m_Logger.LogException(exception);\n        }\n\n    }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231009182751-hpl64yo","Type":"NodeParagraph","Properties":{"id":"20231009182751-hpl64yo"}},{"ID":"20231009182751-vm0c3xh","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231009182751-vm0c3xh","updated":"20231106210632"},"Children":[{"Type":"NodeText","Data":"进阶方法——使用C#API实现"}]},{"ID":"20231009182751-wt669py","Type":"NodeParagraph","Properties":{"id":"20231009182751-wt669py","updated":"20231110175200"},"Children":[{"Type":"NodeText","Data":"使用C#API实现通用的日志类。在使用时实现ILogging接口，按类型（Console\\GUI\\移动GUI\\文件）实现对应的方法。使用静态类调用自定义Logging类的接口就可以了。unityConsole输出添加了双击跳转。"}]},{"ID":"20231110182919-x9f4jht","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"fold":"1","id":"20231110182919-x9f4jht","style":"line-height: 22px;","updated":"20231110182925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"#region 基于C#API实现的日志输出，不依赖于Unity\n\n    public delegate void LogDelegate(string outputLevel, string message);\n\n    /// \u003csummary\u003e\n    /// 输出端类型\n    /// \u003c/summary\u003e\n    public enum OutputType\n    {\n        /// \u003csummary\u003e\n        /// 文件输出\n        /// \u003c/summary\u003e\n        File,\n        /// \u003csummary\u003e\n        /// PC端GUI输出\n        /// \u003c/summary\u003e\n        GUI,\n        /// \u003csummary\u003e\n        /// 移动GUI输出\n        /// \u003c/summary\u003e\n        MobileGUI,\n        /// \u003csummary\u003e\n        /// 控制台输出（unity默认输出）\n        /// \u003c/summary\u003e\n        Console,\n        /// \u003csummary\u003e\n        /// 窗口输出\n        /// \u003c/summary\u003e\n        Window,\n    }\n\n    /// \u003csummary\u003e\n    /// 输出级别\n    /// \u003c/summary\u003e\n    public enum OutputLevel\n    {\n        /// \u003csummary\u003e\n        /// 打开日志信息\n        /// \u003c/summary\u003e\n        On,\n        /// \u003csummary\u003e\n        /// 打印运行信息\n        /// \u003c/summary\u003e\n        Debug,\n        /// \u003csummary\u003e\n        /// 打印感兴趣的信息\n        /// \u003c/summary\u003e\n        Info,\n        /// \u003csummary\u003e\n        /// 打印可能会出错的信息\n        /// \u003c/summary\u003e\n        Warning,\n        /// \u003csummary\u003e\n        /// 打印出错的信息\n        /// \u003c/summary\u003e\n        Error,\n        /// \u003csummary\u003e\n        /// 关闭日志信息\n        /// \u003c/summary\u003e\n        Off,\n    }\n\n    /// \u003csummary\u003e\n    /// 日志数据\n    /// \u003c/summary\u003e\n    public struct LogData\n    {\n        public int LogID;\n        public object LogMessage;\n        public string LogTrace;\n        public DateTime LogTime;\n        public OutputLevel LogLevel;\n    }\n\n    /// \u003csummary\u003e\n    /// 日志信息接口，通过实现该接口来自定义输出方式\n    /// \u003c/summary\u003e\n    public interface ILogging\n    {\n        public void Log(LogData logData);\n    }\n\n    public class Logging\n    {\n        /// \u003csummary\u003e\n        /// 根据输出类型存放日志输出控制\n        /// \u003c/summary\u003e\n        private Dictionary\u003cOutputType, ILogging\u003e m_LogHandlers;\n        /// \u003csummary\u003e\n        /// 堆栈追踪，跳过前3个堆栈帧\n        /// \u003c/summary\u003e\n        private StackTrace StackTrace { get { return new StackTrace(3, true); } }\n        /// \u003csummary\u003e\n        /// 忽略的输出级别，包含的不输出\n        /// \u003c/summary\u003e\n        public List\u003cOutputLevel\u003e IgnoreLevel { get; set; }\n        /// \u003csummary\u003e\n        /// 输出级别控制，低于此级别的不输出\n        /// \u003c/summary\u003e\n        public OutputLevel LogLevel { get; set; } = OutputLevel.On;\n        /// \u003csummary\u003e\n        /// 日志输出开关\n        /// \u003c/summary\u003e\n        public bool LogSwitch { get; set; } = true;\n        /// \u003csummary\u003e\n        /// 日志输出回调\n        /// \u003c/summary\u003e\n        public LogDelegate LogCallBack { get; set; }\n\n        public Logging()\n        {\n            m_LogHandlers = new Dictionary\u003cOutputType, ILogging\u003e();\n            IgnoreLevel = new List\u003cOutputLevel\u003e();\n        }\n\n        /// \u003csummary\u003e\n        /// 添加某个类型的日志输出控制\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"handler\"\u003e\u003c/param\u003e\n        /// \u003cparam name=\"outputType\"\u003e\u003c/param\u003e\n        public void AddLogHandler(ILogging handler, OutputType outputType = OutputType.Console)\n        {\n            if (m_LogHandlers.ContainsKey(outputType))\n            {\n                m_LogHandlers[outputType] = handler;\n            }\n            else\n            {\n                m_LogHandlers.Add(outputType, handler);\n            }\n        }\n\n        /// \u003csummary\u003e\n        /// 移除某个类型的日志输出控制\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"handler\"\u003e\u003c/param\u003e\n        /// \u003cparam name=\"outputType\"\u003e\u003c/param\u003e\n        public void RemoveLogHandler(ILogging handler, OutputType outputType)\n        {\n            if (m_LogHandlers.ContainsKey(outputType))\n            {\n                m_LogHandlers.Remove(outputType);\n            }\n        }\n\n        /// \u003csummary\u003e\n        /// 添加忽略的日志级别\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"level\"\u003e\u003c/param\u003e\n        public void AddIgnoreLogLevel(OutputLevel level)\n        {\n            if (!IgnoreLevel.Contains(level))\n                IgnoreLevel.Add(level);\n        }\n\n        /// \u003csummary\u003e\n        /// 移除忽略的日志级别\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"level\"\u003e\u003c/param\u003e\n        public void RemoveIgnoreLogLevel(OutputLevel level)\n        {\n            if (IgnoreLevel.Contains(level))\n                IgnoreLevel.Remove(level);\n        }\n\n        /// \u003csummary\u003e\n        /// 获取相对Assets的路径\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"path\"\u003e\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private string GetRelativePath(string path)\n        {\n            path = path.Substring(path.IndexOf(\"Assets\"));\n            path = path.Replace('\\\\', '/');\n            return path;\n        }\n\n        /// \u003csummary\u003e\n        /// 获取方法的参数\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"methodBase\"\u003e\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private string GetMethodParameters(System.Reflection.MethodBase methodBase)\n        {\n            StringBuilder stringBuilder = new StringBuilder(1);\n            foreach (var item in methodBase.GetParameters())\n            {\n                stringBuilder.Append(item.ParameterType.Name).Append(\" \");\n            }\n            return stringBuilder.ToString();\n        }\n\n        /// \u003csummary\u003e\n        /// 获取简洁的堆栈帧信息\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"stackFrame\"\u003e堆栈帧\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private string GetStackFrameConcise(StackFrame stackFrame)\n        {\n            return string.Format(\"{0}:{1}({2}) (at {3}:{4,4})\",\n                stackFrame.GetMethod().DeclaringType.Name,\n                stackFrame.GetMethod().Name,\n                GetMethodParameters(stackFrame.GetMethod()),\n                GetRelativePath(stackFrame.GetFileName()),\n                stackFrame.GetFileLineNumber());\n        }\n\n        /// \u003csummary\u003e\n        /// 获取格式化的调用堆栈信息\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"stackTrace\"\u003e堆栈跟踪信息\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private string TraceFormatting(StackTrace stackTrace)\n        {\n            StringBuilder stringBuilder = new StringBuilder(240);\n\n            foreach (StackFrame stackFrame in stackTrace.GetFrames())\n            {\n                stringBuilder.Append(GetStackFrameConcise(stackFrame)).Append(\"\\n\\r\");\n            }\n            return stringBuilder.ToString();\n        }\n\n        /// \u003csummary\u003e\n        /// 获取格式化的异常的调用堆栈信息\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"exception\"\u003e异常\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private string ExceptionTraceFormatting(Exception exception)\n        {\n            StringBuilder stringBuilder = new StringBuilder(240);\n            stringBuilder.Append(\"Error: \" + exception.Message).Append(\"\\n\\r\");\n            if (!string.IsNullOrEmpty(exception.StackTrace))\n            {\n                stringBuilder.Append(exception.StackTrace);\n            }\n            return stringBuilder.ToString();\n        }\n\n        /// \u003csummary\u003e\n        /// 检查是否满足日志输出条件\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"level\"\u003e\u003c/param\u003e\n        /// \u003creturns\u003e\u003c/returns\u003e\n        private bool CheckLogCondition(OutputLevel level)\n        {\n            return LogSwitch \u0026\u0026 level \u003e LogLevel \u0026\u0026 !IgnoreLevel.Contains(level);\n        }\n\n        /// \u003csummary\u003e\n        /// 各级别输出日志通过此方法输出\n        /// \u003c/summary\u003e\n        /// \u003cparam name=\"outputLevel\"\u003e日志级别\u003c/param\u003e\n        /// \u003cparam name=\"message\"\u003e日志信息\u003c/param\u003e\n        /// \u003cparam name=\"trace\"\u003e调用堆栈信息\u003c/param\u003e\n        private void LogBase(OutputLevel outputLevel, object message, string trace)\n        {\n            if (!CheckLogCondition(outputLevel)) return;\n            LogData logData = new LogData();\n            logData.LogLevel = outputLevel;\n            logData.LogMessage = message;\n            logData.LogTime = DateTime.Now;\n            logData.LogTrace = trace;\n\n            foreach (var key in m_LogHandlers.Keys)\n            {\n                m_LogHandlers[key].Log(logData);\n            }\n        }\n\n        #region 各级别输出方法\n        public void Debug(object message)\n        {\n            LogBase(OutputLevel.Debug, message, TraceFormatting(StackTrace));\n        }\n\n        public void Debug(object message, string trace)\n        {\n            LogBase(OutputLevel.Debug, message, trace);\n        }\n\n        public void Debug(string format, params object[] args)\n        {\n            LogBase(OutputLevel.Debug, string.Format(format, args), TraceFormatting(StackTrace));\n        }\n\n        public void Debug(object message, Exception exception)\n        {\n            LogBase(OutputLevel.Debug, message, ExceptionTraceFormatting(exception));\n        }\n\n        public void Info(object message)\n        {\n            LogBase(OutputLevel.Info, message, TraceFormatting(StackTrace));\n        }\n\n        public void Info(string format, params object[] args)\n        {\n            LogBase(OutputLevel.Info, string.Format(format, args), TraceFormatting(StackTrace));\n        }\n\n        public void Info(object message, string trace)\n        {\n            LogBase(OutputLevel.Info, message, TraceFormatting(StackTrace));\n        }\n\n        public void Info(object message, Exception exception)\n        {\n            LogBase(OutputLevel.Info, message, ExceptionTraceFormatting(exception));\n        }\n\n        public void Warn(object message)\n        {\n            LogBase(OutputLevel.Warning, message, TraceFormatting(StackTrace));\n        }\n\n        public void Warn(string format, params object[] args)\n        {\n            LogBase(OutputLevel.Warning, string.Format(format, args), TraceFormatting(StackTrace));\n        }\n\n        public void Warn(object message, string trace)\n        {\n            LogBase(OutputLevel.Warning, message, trace);\n        }\n\n        public void Warn(object message, Exception exception)\n        {\n            LogBase(OutputLevel.Warning, message, ExceptionTraceFormatting(exception));\n        }\n\n        public void Error(object message)\n        {\n            LogBase(OutputLevel.Error, message, TraceFormatting(StackTrace));\n        }\n\n        public void Error(string format, params object[] args)\n        {\n            LogBase(OutputLevel.Error, string.Format(format, args), TraceFormatting(StackTrace));\n        }\n\n        public void Error(object message, string trace)\n        {\n            LogBase(OutputLevel.Error, message, trace);\n        }\n\n        public void Error(object message, Exception exception)\n        {\n            LogBase(OutputLevel.Error, message, ExceptionTraceFormatting(exception));\n        }\n        #endregion\n    }\n\n\n    //----------------------------------------------------------------------------------------------------------\n    //以下为具体实现\n\n\n    /// \u003csummary\u003e\n    /// 文件输出，可继承重写输出\n    /// \u003c/summary\u003e\n    public class LogOutputTypeFile : ILogging\n    {\n        public string m_FilePath { get; set; } = System.IO.Directory.GetCurrentDirectory() + \"/MyLog.txt\";\n\n        private StreamWriter m_Writer;\n\n        public LogOutputTypeFile()\n        {\n            m_Writer = new StreamWriter(m_FilePath, false, Encoding.UTF8);\n        }\n\n        public LogOutputTypeFile(string filePath)\n        {\n            m_FilePath = filePath;\n            m_Writer = new StreamWriter(m_FilePath, false, Encoding.UTF8);\n        }\n\n        public virtual void Log(LogData logData)\n        {\n            m_Writer.Write(\"\\n\\r-----------------------------------------------------------------------------------------------\" +\n                \"\\n\\rID：\" + logData.LogID +\n                \"\\n\\r时间：\" + logData.LogTime +\n                \"\\n\\r级别：\" + logData.LogLevel +\n                \"\\n\\r消息：\" + logData.LogMessage +\n                \"\\n\\r堆栈：\\n\\r\" + logData.LogTrace);\n            m_Writer.Flush();\n        }\n    }\n\n    /// \u003csummary\u003e\n    /// Console输出，可继承重写输出\n    /// \u003c/summary\u003e\n    public class LogOutputTypeConsole : ILogging\n    {\n        public virtual void Log(LogData logData)\n        {\n\n            UnityEngine.Debug.Log(GetLevelFormat(logData.LogLevel) + \" \" + logData.LogMessage + \"\\n\\r堆栈: \" + logData.LogTrace);\n        }\n\n        protected virtual string GetLevelFormat(OutputLevel LogLevel)\n        {\n            switch (LogLevel)\n            {\n                case OutputLevel.Debug:\n                    return $\"\u003ccolor=#FFFFFF\u003e{OutputLevel.Debug.ToString()}: \u003c/color\u003e\";\n                case OutputLevel.Info:\n                    return $\"\u003ccolor=#00E000\u003e{OutputLevel.Info.ToString()}: \u003c/color\u003e\";\n                case OutputLevel.Warning:\n                    return $\"\u003ccolor=#FFFF00\u003e{OutputLevel.Warning.ToString()}: \u003c/color\u003e\";\n                case OutputLevel.Error:\n                    return $\"\u003ccolor=#FF0000\u003e{OutputLevel.Error.ToString()}: \u003c/color\u003e\";\n            }\n            return \"Level Error!\";\n        }\n\n        private static string GetStackTraceText()\n        {\n            var consoleWindowType = typeof(UnityEditor.EditorWindow).Assembly.GetType(\"UnityEditor.ConsoleWindow\");\n            var fieldInfo = consoleWindowType.GetField(\"ms_ConsoleWindow\",\n                System.Reflection.BindingFlags.Static |\n                System.Reflection.BindingFlags.NonPublic);\n            var consoleWindowInstance = fieldInfo.GetValue(null);\n\n            if (consoleWindowInstance != null)\n            {\n                if ((object)UnityEditor.EditorWindow.focusedWindow == consoleWindowInstance)\n                {\n                    fieldInfo = consoleWindowType.GetField(\"m_ActiveText\",\n                        System.Reflection.BindingFlags.Instance |\n                        System.Reflection.BindingFlags.NonPublic);\n                    string activeText = fieldInfo.GetValue(consoleWindowInstance).ToString();\n                    return activeText;\n                }\n            }\n            return null;\n        }\n\n        [UnityEditor.Callbacks.OnOpenAssetAttribute(0)]\n        private static bool OnOpenAsset(int instanceID, int line)\n        {\n            string stackTrace = GetStackTraceText();\n            if (!string.IsNullOrEmpty(stackTrace) \u0026\u0026 stackTrace.Contains(\"LogTool.cs\"))\n            {\n                var matches = System.Text.RegularExpressions.Regex.Match(stackTrace, @\"\\(at (.+)\\)\", System.Text.RegularExpressions.RegexOptions.IgnoreCase);\n\n                string pathLine = \"\";\n                while (matches.Success)\n                {\n                    pathLine = matches.Groups[1].Value;\n\n                    if (!pathLine.Contains(\"LogTool.cs\"))\n                    {\n                        int splitIndex = pathLine.IndexOf(':');\n                        //脚本路径\n                        string path = pathLine.Substring(0, splitIndex);\n                        //行号\n                        line = System.Convert.ToInt32(pathLine.Substring(splitIndex + 1));\n\n                        string fullPath = Application.dataPath.Substring(0, Application.dataPath.LastIndexOf(\"Assets\"));\n                        fullPath = fullPath + path;\n                        //跳转到目标代码指定行\n                        UnityEditorInternal.InternalEditorUtility.OpenFileAtLineExternal(fullPath, line);\n                        break;\n                    }\n                    matches = matches.NextMatch();\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public class LogTool\n    {\n        private static Logging m_Logging;\n        private static LogOutputTypeFile m_TypeFile;\n        private static LogOutputTypeConsole m_TypeConsole;\n        static LogTool()\n        {\n            m_Logging = new Logging();\n            m_TypeFile = new LogOutputTypeFile();\n            m_TypeConsole = new LogOutputTypeConsole();\n            m_Logging.AddLogHandler(m_TypeFile, OutputType.File);\n            m_Logging.AddLogHandler(m_TypeConsole, OutputType.Console);\n        }\n\n        public static void LogDebug(object message)\n        {\n            m_Logging.Debug(message);\n        }\n        public static void LogDebug(object message, Exception exception)\n        {\n            m_Logging.Debug(message, exception);\n        }\n        public static void LogDebug(object message, string trace)\n        {\n            m_Logging.Debug(message, trace);\n        }\n        public static void LogDebug(string format, params object[] objs)\n        {\n            m_Logging.Debug(format, objs);\n        }\n        public static void LogInfo(object message)\n        {\n            m_Logging.Info(message);\n        }\n        public static void LogInfo(object message, Exception exception)\n        {\n            m_Logging.Info(message, exception);\n        }\n        public static void LogInfo(object message, string trace)\n        {\n            m_Logging.Info(message, trace);\n        }\n        public static void LogInfo(string format, params object[] objs)\n        {\n            m_Logging.Info(format, objs);\n        }\n        public static void LogWarn(object message)\n        {\n            m_Logging.Warn(message);\n        }\n        public static void LogWarn(object message, Exception exception)\n        {\n            m_Logging.Warn(message, exception);\n        }\n        public static void LogWarn(object message, string trace)\n        {\n            m_Logging.Warn(message, trace);\n        }\n        public static void LogWarn(string format, params object[] objs)\n        {\n            m_Logging.Warn(format, objs);\n        }\n        public static void LogError(object message)\n        {\n            m_Logging.Error(message);\n        }\n        public static void LogError(object message, Exception exception)\n        {\n            m_Logging.Error(message, exception);\n        }\n        public static void LogError(object message, string trace)\n        {\n            m_Logging.Error(message, trace);\n        }\n        public static void LogError(string format, params object[] objs)\n        {\n            m_Logging.Error(format, objs);\n        }\n    }\n\n    #endregion\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20231009182752-qmdoufn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20231009182752-qmdoufn","updated":"20231009182809"},"Children":[{"Type":"NodeText","Data":"参考资料"}]},{"ID":"20231009182811-phdj670","Type":"NodeParagraph","Properties":{"id":"20231009182811-phdj670","updated":"20231009182811"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/u014361280/article/details/104204586","TextMarkTextContent":"Unity 工具类 之 简单的日志打印封装 LogWrapper 的实现_仙魁XAN的博客-CSDN博客"}]},{"ID":"20231009182812-o9qtssv","Type":"NodeParagraph","Properties":{"id":"20231009182812-o9qtssv","updated":"20231009182854"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/YasinXin/article/details/90643609","TextMarkTextContent":"Unity自定义日志系统_unity 写自定义日志-CSDN博客"}]},{"ID":"20231009185228-mbqcx6u","Type":"NodeParagraph","Properties":{"id":"20231009185228-mbqcx6u","updated":"20231009185228"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/seek_yang/article/details/121685307","TextMarkTextContent":"Unity3D 开发工具系列 日志系统：核心模块Logging_unity loging-CSDN博客"}]},{"ID":"20231107172642-pymjpdj","Type":"NodeParagraph","Properties":{"id":"20231107172642-pymjpdj","updated":"20231107172642"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/linxinfa/article/details/119280053","TextMarkTextContent":"【精选】【游戏开发进阶】新发带你玩转Unity日志打印技巧（彩色日志 | 日志存储与上传 | 日志开关 | 日志双击溯源）_unity 如何打印object_林新发的博客-CSDN博客"}]},{"ID":"20231110175054-j9smmsa","Type":"NodeParagraph","Properties":{"id":"20231110175054-j9smmsa","updated":"20231110175054"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/f_957995490/article/details/107872442","TextMarkTextContent":"详解(C"},{"Type":"NodeTextMark","TextMarkType":"a tag","TextMarkAHref":"https://blog.csdn.net/f_957995490/article/details/107872442","TextMarkTextContent":") .NET反射中的BindingFlags以及常用的BindingFlags使用方式_c"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://blog.csdn.net/f_957995490/article/details/107872442","TextMarkTextContent":" bindingflags-CSDN博客"}]},{"ID":"20231110182939-l18vr8p","Type":"NodeParagraph","Properties":{"id":"20231110182939-l18vr8p"}}]}