{"ID":"20251011183609-mlaoe6p","Spec":"2","Type":"NodeDocument","Properties":{"id":"20251011183609-mlaoe6p","title":"Unity 文字弯曲","type":"doc","updated":"20260209112539"},"Children":[{"ID":"20251020101934-06b6327","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251020101934-06b6327","linenumber":"true","style":"line-height: 22px;","updated":"20251020104625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"QyM="},{"Type":"NodeCodeBlockCode","Data":"using TMPro;\nusing UnityEngine;\n\npublic enum CurveType\n{\n    Sin,\n    Circle,\n    Curve,\n}\n\n[ExecuteAlways, RequireComponent(typeof(TextMeshProUGUI))]\npublic class TextMeshProCurve : MonoBehaviour\n{\n    public CurveType _CurveType;\n    public TextMeshProUGUI _TextComponent;\n\n    #region Sin成员变量\n\n    [SerializeField, Tooltip(\"波浪振幅\"), ShowIf(\"_CurveType\",CurveType.Sin)]\n    private float _amplitude = 5f;\n\n    [SerializeField, Tooltip(\"波浪周期\"), ShowIf(\"_CurveType\",CurveType.Sin)]\n    private float _period = .5f;\n\n    [SerializeField, Tooltip(\"波浪速度\"), ShowIf(\"_CurveType\",CurveType.Sin)]\n    private float _waveSpeed = 1f;\n\n    [SerializeField, Tooltip(\"整体Y轴偏移\"), ShowIf(\"_CurveType\",CurveType.Sin)]\n    private float _offsetY;\n\n    #endregion\n\n    #region Circle成员变量\n\n    [SerializeField, Tooltip(\"半径\"), ShowIf(\"_CurveType\",CurveType.Circle)]\n    private float _radius = 500.0f;\n\n    #endregion\n\n    #region Curve成员变量\n\n    [ShowIf(\"_CurveType\",CurveType.Curve)] \n    public AnimationCurve _Curve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(1, 0), new Keyframe(0.5f, 1));\n\n    [SerializeField, ShowIf(\"_CurveType\",CurveType.Curve)]\n    private float _curveScale = 100f;\n\n    #endregion\n\n    private void Awake()\n    {\n        _TextComponent = gameObject.GetComponent\u003cTextMeshProUGUI\u003e();\n    }\n\n    private void OnEnable()\n    {\n        //Sin和Circle需要在渲染前修改顶点，但Curve需要在渲染后修改\n        _TextComponent.OnPreRenderText += UpdateTextCurve;\n    }\n\n    private void OnDisable()\n    {\n        _TextComponent.OnPreRenderText -= UpdateTextCurve;\n    }\n\n    private int _num = 1;\n#if UNITY_EDITOR\n    //仅限开发者调用，当脚本加载或Inspector上的值被修改时调用。执行可能发生在不同时间，可能在Awake和Start之前\n    private void OnValidate()\n    {\n        //延迟几帧调用一次\n        if (_num++ % 3 != 0)\n            OnCurvePropertyChanged();\n    }\n#endif\n\n    private void Update()\n    {\n        if (_CurveType == CurveType.Sin)\n        {\n            OnCurvePropertyChanged();\n        }\n    }\n\n    private void OnCurvePropertyChanged()\n    {\n        UpdateTextCurve(_TextComponent.textInfo);\n        _TextComponent.ForceMeshUpdate();\n    }\n\n    private void UpdateTextCurve(TMP_TextInfo textInfo)\n    {\n        if (textInfo == null) return;\n        switch (_CurveType)\n        {\n            case CurveType.Sin:\n                WarpTextSin(textInfo);\n                break;\n            case CurveType.Circle:\n                WarpTextCircle(textInfo);\n                break;\n            case CurveType.Curve:\n                WarpTextCurve(textInfo);\n                break;\n        }\n    }\n\n    #region Sin\n\n    /*\n     Sin位置计算解释\n    正弦函数 y = A·sin(Bx + C) + D\n    A为振幅，初始sin范围在[-1,1]，乘以A后变为[-A,A]\n    B为周期，sin标准周期为2π，因此这里实际为2π/B，B越大周期越小\n    C为相位，它是一个让波形在X轴上水平移动的偏移量，控制波浪的起始位置\n    D为Y轴偏移，控制波形在Y轴上整体的偏移\n    */\n    private void WarpTextSin(TMP_TextInfo textInfo)\n    {\n        //随时间变化的相位\n        float phase = Time.time * _waveSpeed;\n\n        for (int i = 0; i \u003c textInfo.characterInfo.Length; i++)\n        {\n            if (!textInfo.characterInfo[i].isVisible) continue;\n\n            int vertexIndex = textInfo.characterInfo[i].vertexIndex;\n            int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n            var vertexs = textInfo.meshInfo[materialIndex].vertices;\n\n            for (int j = 0; j \u003c 4; j++)\n            {\n                //这里使用vertexs[vertexIndex + j].x代替i也可以，但是字符会变形，因为会导致同一个字符的4个角偏移量不一样\n                float sinOffset = _amplitude * Mathf.Sin(i * _period + phase) + _offsetY;\n                vertexs[vertexIndex + j] += new Vector3(0, sinOffset, 0);\n            }\n        }\n    }\n\n    #endregion\n\n    #region Circle\n\n    private void WarpTextCircle(TMP_TextInfo textInfo)\n    {\n        Vector3[] vertices;\n        Matrix4x4 matrix;\n\n        //遍历文本的所有字符\n        for (int i = 0; i \u003c textInfo.characterInfo.Length; i++)\n        {\n            //不可见的字符，跳过\n            if (!textInfo.characterInfo[i].isVisible)\n                continue;\n\n            //获取当前字符的顶点下标和所用材质下标\n            int vertexIndex = textInfo.characterInfo[i].vertexIndex;\n            int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n            //获取所有字符顶点。顶点顺序：左下，左上，右上，右下\n            vertices = textInfo.meshInfo[materialIndex].vertices;\n\n            //计算字符自身在基准线上的中点位置（x为字符中心点，y为基准线的y值）---》以屏幕坐标为原点\n            Vector3 charMidBaselinePos = new Vector2(\n                (vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2,\n                textInfo.characterInfo[i].baseLine);\n\n            //将字符的位置调整为以自身在基准线上的中点位置为原点，而不是以屏幕坐标为原点\n            vertices[vertexIndex + 0] += -charMidBaselinePos;\n            vertices[vertexIndex + 1] += -charMidBaselinePos;\n            vertices[vertexIndex + 2] += -charMidBaselinePos;\n            vertices[vertexIndex + 3] += -charMidBaselinePos;\n\n            //计算字符的Transform矩阵\n            matrix = ComputeTransformationMatrix(charMidBaselinePos, textInfo, i);\n\n            //将每一个顶点的Transform矩阵应用。matrix.MultiplyPoint3x4作用为将目标Vector3进行矩阵变换\n            vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);\n            vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);\n            vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);\n            vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);\n        }\n    }\n\n    /*计算矩阵解释\n    //charMidBaselinePos.x / circumference：此时文本仍然为直线，将圆周长看做基准线的长度，这里表示的是字符在圆上的百分比位置\n    //字符在圆上的百分比位置范围是[0,1]，-0.5是将范围调整到[-0.5,0.5]，因为需要将字符放到对称的位置上\n    //将占周长的比例*360可以得到该比例对应的角度，+90将基准线从x轴正方向调整为y轴正方向，*Mathf.Deg2Rad将角度转为弧度\n    //圆上某点的位置计算：targetX = 半径 * Mathf.Cos(angle)；targetY = 半径 * Mathf.Sin(angle)\n    //Mathf.Atan2计算（x，y）向量与（1，0）单位向量之间的弧度。*Mathf.Rad2Deg转为角度。-90将将基准线从x轴正方向调整为y轴正方向\n    */\n    private Matrix4x4 ComputeTransformationMatrix(Vector3 charMidBaselinePos, TMP_TextInfo textInfo, int charIdx)\n    {\n        //计算当前实际的半径，文本的每一行基准线都可能不同\n        float radiusForThisLine = _radius + textInfo.lineInfo[textInfo.characterInfo[charIdx].lineNumber].baseline;\n\n        //计算圆周长\n        float circumference = 2 * radiusForThisLine * Mathf.PI;\n\n        //计算当前点在圆周上的角度\n        float angle = ((charMidBaselinePos.x / circumference - 0.5f) * 360 + 90) * Mathf.Deg2Rad;\n\n        //计算字符在圆上的位置\n        float x0 = Mathf.Cos(angle);\n        float y0 = Mathf.Sin(angle);\n\n        //创建字符在圆上的位置坐标\n        Vector2 newMidBaselinePos = new Vector2(x0 * radiusForThisLine, -y0 * radiusForThisLine - _radius);\n\n        //计算字符的旋转角度\n        float rotationAngle = -Mathf.Atan2(y0, x0) * Mathf.Rad2Deg - 90;\n\n        //创建新的Transform矩阵，这里还没有真的改变字符的Transform，Rotate,Scale\n        return Matrix4x4.TRS(\n            new Vector3(newMidBaselinePos.x, newMidBaselinePos.y, 0),\n            Quaternion.AngleAxis(rotationAngle, Vector3.forward),\n            Vector3.one\n        );\n    }\n\n    #endregion\n\n    #region Curve\n\n    /*\n     * 角度计算解释\n     * 切线和x轴正方向的夹角就是要旋转的角度，可以画个图看\n     * 点乘公式：a·b = |a| *|b| *cos\u003ca,b\u003e 当a,b为单位向量时简化为a·b = cos\u003ca,b\u003e，所以Vector.Dot得到的值为cos\u003ca,b\u003e\n     * Mathf.Cos是知道角度求正切值，Mathf.Acos是知道正切值求角度。实际上unity返回的是弧度，所以乘以Mathf.Rad2Deg(常数)\n     * 点乘求角度，叉乘求方向，计算叉乘得到这两个向量构成平面的垂直向量cross，cross向外则角度\u003e0\n     * 角度\u003c0时，360-dot其实就是角度顺时针旋转的角度\n     */\n    private void WarpTextCurve(TMP_TextInfo textInfo)\n    {\n        //在这里ForceMeshUpdate不能与OnPreRenderText同时使用，会导致栈溢出，Unity崩溃\n        //_TextComponent.ForceMeshUpdate();\n\n        //使用rect替换bounds。因为OnPreRenderText，会在渲染之前调用，bounds在第一次渲染之前可能为0\n        var boundMinX = _TextComponent.rectTransform.rect.xMin; //_TextComponent.bounds.min.x;\n        var boundMaxX = _TextComponent.rectTransform.rect.xMax; //_TextComponent.bounds.max.x;\n\n        for (int i = 0; i \u003c textInfo.characterInfo.Length; i++)\n        {\n            if (!textInfo.characterInfo[i].isVisible) continue;\n\n            var vertexIndex = textInfo.characterInfo[i].vertexIndex;\n            var materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n            var vertices = textInfo.meshInfo[materialIndex].vertices;\n            //获取当前字符中点位置(基线高度)\n            Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine);\n\n            vertices[vertexIndex + 0] += -offsetToMidBaseline;\n            vertices[vertexIndex + 1] += -offsetToMidBaseline;\n            vertices[vertexIndex + 2] += -offsetToMidBaseline;\n            vertices[vertexIndex + 3] += -offsetToMidBaseline;\n\n            //计算当前字符每个顶点的位置和角度\n\n            //当前字符中点坐标x，占文本总长度的比例\n            if (boundMaxX - boundMinX \u003c= 0) return; //除数不能为0\n            var x0 = (offsetToMidBaseline.x - boundMinX) / (boundMaxX - boundMinX);\n            //曲线的x,y范围是[0,1]，原本是直线可以看做y = 0，直接成比例扩大就可以作为posY\n            var y0 = _Curve.Evaluate(x0) * _curveScale;\n\n            //获取相近的点，用于计算切线\n            var x1 = x0 + 0.0001f;\n            var y1 = _Curve.Evaluate(x1) * _curveScale;\n\n            //计算切线和角度\n            var tangent = new Vector3(x1 * (boundMaxX - boundMinX) + boundMinX, y1) - new Vector3(offsetToMidBaseline.x, y0);\n            var dot = Mathf.Acos(Vector3.Dot(Vector3.right, tangent.normalized)) * 57.2957795f;\n            var cross = Vector3.Cross(Vector3.right, tangent);\n            var angle = cross.z \u003e 0 ? dot : 360 - dot;\n\n            var matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one);\n\n            vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);\n            vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);\n            vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);\n            vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);\n\n            vertices[vertexIndex + 0] += offsetToMidBaseline;\n            vertices[vertexIndex + 1] += offsetToMidBaseline;\n            vertices[vertexIndex + 2] += offsetToMidBaseline;\n            vertices[vertexIndex + 3] += offsetToMidBaseline;\n        }\n\n        _TextComponent.UpdateVertexData();\n    }\n\n    #endregion\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251020102103-kk37kwn","Type":"NodeParagraph","Properties":{"id":"20251020102103-kk37kwn","updated":"20251020102103"}},{"ID":"20251020104641-1npe12f","Type":"NodeParagraph","Properties":{"id":"20251020104641-1npe12f","updated":"20251020104641"}},{"ID":"20251020104641-yc36bnp","Type":"NodeParagraph","Properties":{"id":"20251020104641-yc36bnp","updated":"20251020104641"}},{"ID":"20251020104642-3c0y5b8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251020104642-3c0y5b8","linenumber":"true","updated":"20251020104700"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"QyM="},{"Type":"NodeCodeBlockCode","Data":"using System;\n\n[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]\npublic class ShowIfAttribute : Attribute\n{\n    public string _TargetName;\n    public int _TargetValue;\n    \n    public ShowIfAttribute(string targetName,object targetValue)\n    {\n        _TargetName = targetName;\n        _TargetValue = (int)targetValue;\n    }\n}\n\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251020104702-ed1u51i","Type":"NodeParagraph","Properties":{"id":"20251020104702-ed1u51i","updated":"20251020104702"}},{"ID":"20251020104705-5ovcn8r","Type":"NodeParagraph","Properties":{"id":"20251020104705-5ovcn8r","updated":"20251020104705"}},{"ID":"20251020104705-czvxd02","Type":"NodeParagraph","Properties":{"id":"20251020104705-czvxd02","updated":"20251020104705"}},{"ID":"20251020104706-1qfy5em","Type":"NodeParagraph","Properties":{"id":"20251020104706-1qfy5em","updated":"20251020104805"},"Children":[{"Type":"NodeText","Data":"Editor文件夹下："}]},{"ID":"20251020104706-k65wn4k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251020104706-k65wn4k","linenumber":"true","updated":"20251020104725"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"QyM="},{"Type":"NodeCodeBlockCode","Data":"using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomEditor(typeof(TextMeshProCurve))]\npublic class ShowIfEditor : Editor\n{\n    private SerializedProperty _showCondition;\n\n    override public void OnInspectorGUI()\n    {\n        //同步实际对象数据到序列化数据\n        serializedObject.Update();\n\n        //获取TextMeshProCurve所有字段和属性，筛选被ShowIf标记的\n        var fields = target.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)\n            .Where(field =\u003e !field.IsDefined(typeof(HideInInspector), true));\n        var properties = target.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)\n            .Where(property =\u003e property.CanRead \u0026\u0026 property.IsDefined(typeof(ShowIfAttribute), true));\n\n        //判断字段和属性是否显示\n        foreach (var field in fields)\n        {\n            var showIf = field.GetCustomAttribute\u003cShowIfAttribute\u003e();\n            if (showIf == null || IsShow(showIf))\n            {\n                DrawField(field);\n            }\n        }\n\n        foreach (var property in properties)\n        {\n            var showIf = property.GetCustomAttribute\u003cShowIfAttribute\u003e();\n            if (showIf == null || IsShow(showIf))\n            {\n                DrawProperty(property);\n            }\n        }\n        \n        //应用修改到序列化数据\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    //绘制字段\n    private void DrawField(FieldInfo field)\n    {\n        //这里查找到的是字段信息\n        var property = serializedObject.FindProperty(field.Name);\n        if (property != null)\n        {\n            EditorGUILayout.PropertyField(property);\n        }\n    }\n\n    //绘制属性\n    private void DrawProperty(PropertyInfo property)\n    {\n        if (!property.CanWrite || !property.CanRead) return;\n\n        var label = new GUIContent(ObjectNames.NicifyVariableName(property.Name));\n        var value = property.GetValue(target);\n        \n        if (value is float floatValue)\n        {\n            float newValue = EditorGUILayout.FloatField(label, floatValue);\n            if (!Mathf.Approximately(newValue, floatValue))\n            {\n                property.SetValue(target, newValue);\n            }\n        }\n        else if (value is int intValue)\n        {\n            int newValue = EditorGUILayout.IntField(label, intValue);\n            if (newValue != intValue)\n            {\n                property.SetValue(target, newValue);\n            }\n        }\n        else if (value is bool boolValue)\n        {\n            bool newValue = EditorGUILayout.Toggle(label, boolValue);\n            if (newValue != boolValue)\n            {\n                property.SetValue(target, newValue);\n            }\n        }\n        else if (value is string stringValue)\n        {\n            string newValue = EditorGUILayout.TextField(label, stringValue);\n            if (newValue != stringValue)\n            {\n                property.SetValue(target, newValue);\n            }\n        }\n        else if (value is double doubleValue)\n        {\n            double newValue = EditorGUILayout.DoubleField(label, doubleValue);\n            if (Math.Abs(newValue - doubleValue) \u003e 0.0000001f)\n            {\n                property.SetValue(target, newValue);\n            }\n        }\n\n        EditorUtility.SetDirty(target);\n    }\n\n    //是否显示\n    private bool IsShow(ShowIfAttribute showIf)\n    {\n        _showCondition = serializedObject.FindProperty(showIf._TargetName);\n        return _showCondition.enumValueIndex == showIf._TargetValue;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251020105229-nfigl4i","Type":"NodeParagraph","Properties":{"id":"20251020105229-nfigl4i","updated":"20251020105229"}}]}