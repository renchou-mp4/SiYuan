{"ID":"20250709020907-v01hpke","Spec":"2","Type":"NodeDocument","Properties":{"id":"20250709020907-v01hpke","title":"C# 组合哈希码的几种方式","type":"doc","updated":"20250709021619"},"Children":[{"ID":"20250709021006-lxwsnut","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250709021006-lxwsnut","updated":"20250709021207"},"Children":[{"Type":"NodeText","Data":"一、GameFramework中使用^组合哈希码"}]},{"ID":"20250709021002-8na7jpo","Type":"NodeParagraph","Properties":{"id":"20250709021002-8na7jpo","updated":"20250709021043"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 类中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetHashCode"},{"Type":"NodeText","Data":"​ 方法使用按位异或运算符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​ 来组合类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Type"},{"Type":"NodeText","Data":"​ 和名称 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Name"},{"Type":"NodeText","Data":"​ 的哈希码"}]},{"ID":"20250709021002-9ic9uq8","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021002-9ic9uq8","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"代码示例"}]},{"ID":"20250709021002-nd5uqpl","Type":"NodeParagraph","Properties":{"id":"20250709021002-nd5uqpl","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021002-68x063n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021002-68x063n","updated":"20250709021002"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"public override int GetHashCode()\n{\n    return m_Type.GetHashCode() ^ m_Name.GetHashCode();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021002-wxqk425","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021002-wxqk425","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"原因分析"}]},{"ID":"20250709021002-mspgco8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250709021002-mspgco8","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"1. 哈希码的组合需求"}]},{"ID":"20250709021002-4t2ea7z","Type":"NodeParagraph","Properties":{"id":"20250709021002-4t2ea7z","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"哈希码（hash code）是一个整数值，用于在哈希表（如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Dictionary"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashSet"},{"Type":"NodeText","Data":"​ 等）中快速查找和比较对象。当使用自定义类型作为哈希表的键时，需要为该类型重写 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetHashCode"},{"Type":"NodeText","Data":"​ 方法，以确保具有相同内容的对象产生相同的哈希码，不同内容的对象尽可能产生不同的哈希码。"}]},{"ID":"20250709021002-d8mxbdj","Type":"NodeParagraph","Properties":{"id":"20250709021002-d8mxbdj","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 类中，它由类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Type"},{"Type":"NodeText","Data":"​ 和名称 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Name"},{"Type":"NodeText","Data":"​ 两个属性组成，为了生成一个能代表整个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 实例的哈希码，需要将这两个属性的哈希码组合起来。"}]},{"ID":"20250709021002-ys34sur","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250709021002-ys34sur","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"2. 按位异或运算符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​ 的特性"}]},{"ID":"20250709021002-ug7jjxs","Type":"NodeParagraph","Properties":{"id":"20250709021002-ug7jjxs","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"按位异或运算符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​ 具有以下特性，使其适合用于组合哈希码："}]},{"ID":"20250709021002-bzurk6v","Type":"NodeList","ListData":{},"Properties":{"id":"20250709021002-bzurk6v","updated":"20250709021002"},"Children":[{"ID":"20250709021002-wkneokl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250709021002-wkneokl","updated":"20250709021002"},"Children":[{"ID":"20250709021002-jmg8gpe","Type":"NodeParagraph","Properties":{"id":"20250709021002-jmg8gpe","updated":"20250709021002"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"简单高效"},{"Type":"NodeText","Data":"：按位异或运算是一种位级操作，计算速度非常快，不会带来过多的性能开销。"}]}]},{"ID":"20250709021002-wdpt501","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250709021002-wdpt501","updated":"20250709021002"},"Children":[{"ID":"20250709021002-zgi6w18","Type":"NodeParagraph","Properties":{"id":"20250709021002-zgi6w18","updated":"20250709021002"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"均匀分布"},{"Type":"NodeText","Data":"：按位异或运算可以将两个哈希码的位信息混合起来，使得组合后的哈希码更有可能均匀分布在整个整数范围内。这样可以减少哈希冲突的概率，提高哈希表的性能。"}]}]},{"ID":"20250709021002-jru21n5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250709021002-jru21n5","updated":"20250709021002"},"Children":[{"ID":"20250709021002-o21o1pi","Type":"NodeParagraph","Properties":{"id":"20250709021002-o21o1pi","updated":"20250709021002"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可交换性"},{"Type":"NodeText","Data":"：按位异或运算满足交换律，即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a ^ b"},{"Type":"NodeText","Data":"​ 等于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"b ^ a"},{"Type":"NodeText","Data":"​。这意味着属性的顺序不会影响最终的哈希码，保证了哈希码的一致性。"}]}]}]},{"ID":"20250709021002-3rth0t5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250709021002-3rth0t5","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"3. 避免哈希冲突"}]},{"ID":"20250709021002-rbntmx5","Type":"NodeParagraph","Properties":{"id":"20250709021002-rbntmx5","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"哈希冲突是指不同的对象产生了相同的哈希码。使用按位异或运算符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​ 组合哈希码可以在一定程度上减少哈希冲突的发生。例如，如果只使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Type"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Name"},{"Type":"NodeText","Data":"​ 的哈希码作为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 的哈希码，那么只要 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Type"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m_Name"},{"Type":"NodeText","Data":"​ 相同，就会产生相同的哈希码，导致大量的哈希冲突。而通过按位异或运算将两个属性的哈希码组合起来，可以使不同的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 实例产生不同的哈希码，降低哈希冲突的概率。"}]},{"ID":"20250709021002-lt3mm9u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021002-lt3mm9u","updated":"20250709021112"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250709021002-chympn2","Type":"NodeParagraph","Properties":{"id":"20250709021002-chympn2","updated":"20250709021002"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 类的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetHashCode"},{"Type":"NodeText","Data":"​ 方法中使用按位异或运算符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​ 是为了高效、均匀地组合类型和名称的哈希码，减少哈希冲突的发生，提高哈希表的性能。这样可以确保在使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeNamePair"},{"Type":"NodeText","Data":"​ 作为哈希表的键时，能够快速、准确地查找和比较对象。"}]},{"ID":"20250709021111-navcngq","Type":"NodeParagraph","Properties":{"id":"20250709021111-navcngq","updated":"20250709021111"}},{"ID":"20250709021111-l5hgoaz","Type":"NodeParagraph","Properties":{"id":"20250709021111-l5hgoaz","updated":"20250709021111"}},{"ID":"20250709021112-py3rend","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250709021112-py3rend","updated":"20250709021210"},"Children":[{"Type":"NodeText","Data":"二、其他组合哈希码的方式及各自优劣"}]},{"ID":"20250709021155-2cahfp0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021155-2cahfp0","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"1. 简单相加"}]},{"ID":"20250709021155-2lq0vv9","Type":"NodeParagraph","Properties":{"id":"20250709021155-2lq0vv9","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"简单相加是一种非常直接的组合哈希码的方式，即将各个属性的哈希码相加。这种方法简单易实现，但可能会导致哈希冲突的概率较高，尤其是当属性的哈希码分布不均匀时。"}]},{"ID":"20250709021155-3p4uk1b","Type":"NodeParagraph","Properties":{"id":"20250709021155-3p4uk1b","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021155-xkmn9bt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021155-xkmn9bt","updated":"20250709021155"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"public override int GetHashCode()\n{\n    return m_Type.GetHashCode() + m_Name.GetHashCode();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021155-e05vlwj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021155-e05vlwj","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"2. 乘以不同的质数"}]},{"ID":"20250709021155-lrdr51j","Type":"NodeParagraph","Properties":{"id":"20250709021155-lrdr51j","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"通过将各个属性的哈希码乘以不同的质数，然后再相加，可以在一定程度上减少哈希冲突的概率。质数的选择可以根据实际情况进行调整，通常选择一些较小的质数，如 31、37 等。"}]},{"ID":"20250709021155-f2x4x6y","Type":"NodeParagraph","Properties":{"id":"20250709021155-f2x4x6y","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021155-txy2eg2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021155-txy2eg2","updated":"20250709021155"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"public override int GetHashCode()\n{\n    int prime1 = 31;\n    int prime2 = 37;\n    return prime1 * m_Type.GetHashCode() + prime2 * m_Name.GetHashCode();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021155-8zfaq3l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021155-8zfaq3l","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"3. 使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashCode.Combine"},{"Type":"NodeText","Data":"​ 方法（.NET Core 2.1 及以上版本）"}]},{"ID":"20250709021155-7rsvedx","Type":"NodeParagraph","Properties":{"id":"20250709021155-7rsvedx","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"在 .NET Core 2.1 及以上版本中，提供了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashCode.Combine"},{"Type":"NodeText","Data":"​ 方法，该方法可以方便地组合多个属性的哈希码。它会自动处理哈希码的组合和溢出问题，并且能够生成较为均匀分布的哈希码。"}]},{"ID":"20250709021155-98rutn9","Type":"NodeParagraph","Properties":{"id":"20250709021155-98rutn9","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021155-dl4e80m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021155-dl4e80m","updated":"20250709021155"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"public override int GetHashCode()\n{\n    return HashCode.Combine(m_Type, m_Name);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021155-dwpdyyi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021155-dwpdyyi","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"4. 使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"System.Tuple"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueTuple"},{"Type":"NodeText","Data":"​"}]},{"ID":"20250709021155-2vpls6l","Type":"NodeParagraph","Properties":{"id":"20250709021155-2vpls6l","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"System.Tuple"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueTuple"},{"Type":"NodeText","Data":"​ 都实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"GetHashCode"},{"Type":"NodeText","Data":"​ 方法，可以利用它们来组合多个属性的哈希码。这种方法简单方便，但可能会带来一些额外的性能开销。"}]},{"ID":"20250709021155-gywsnsc","Type":"NodeParagraph","Properties":{"id":"20250709021155-gywsnsc","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021155-7wb4kiu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021155-7wb4kiu","updated":"20250709021155"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"// 使用 System.Tuple\npublic override int GetHashCode()\n{\n    return Tuple.Create(m_Type, m_Name).GetHashCode();\n}\n\n// 使用 ValueTuple\npublic override int GetHashCode()\n{\n    return (m_Type, m_Name).GetHashCode();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021155-jw0z2qk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250709021155-jw0z2qk","updated":"20250709021619"},"Children":[{"Type":"NodeText","Data":"5. 自定义加权组合"}]},{"ID":"20250709021155-mvyklq1","Type":"NodeParagraph","Properties":{"id":"20250709021155-mvyklq1","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"根据属性的重要性或分布情况，可以为每个属性的哈希码分配不同的权重，然后再进行组合。这种方法可以根据具体需求进行灵活调整，以达到更好的哈希效果。"}]},{"ID":"20250709021155-2t3ckfh","Type":"NodeParagraph","Properties":{"id":"20250709021155-2t3ckfh","updated":"20250709021155"},"Children":[{"Type":"NodeText","Data":"csharp"}]},{"ID":"20250709021155-dloutb2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250709021155-dloutb2","updated":"20250709021155"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"public override int GetHashCode()\n{\n    int weight1 = 2;\n    int weight2 = 3;\n    return weight1 * m_Type.GetHashCode() + weight2 * m_Name.GetHashCode();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250709021155-j8y5vse","Type":"NodeParagraph","Properties":{"id":"20250709021155-j8y5vse","updated":"20250709021226"}},{"ID":"20250709021244-3c9v62s","Type":"NodeTable","TableAligns":[0,0,0],"Properties":{"colgroup":"||","id":"20250709021244-3c9v62s","updated":"20250709021619"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"组合方法"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"优点"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"缺点"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"简单相加"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"实现极其简单，代码量少，容易理解和维护。计算速度快，没有复杂的运算逻辑。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"哈希冲突概率较高，尤其是当属性的哈希码分布不均匀时，容易产生大量相同的哈希码。没有考虑属性之间的独立性，不同的属性组合可能得到相同的哈希码。"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"乘以不同的质数"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"通过质数的特性，在一定程度上减少了哈希冲突的概率，使得哈希码分布更加均匀。实现相对简单，性能开销较小。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"质数的选择需要一定的经验和实验，不合适的质数可能无法有效减少哈希冲突。仍然存在一定的哈希冲突风险，尤其是在属性数量较多或哈希码分布特殊的情况下。"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashCode.Combine"},{"Type":"NodeText","Data":"​ 方法（.NET Core 2.1 及以上）"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"使用方便，无需手动处理哈希码的组合和溢出问题。能够生成较为均匀分布的哈希码，有效降低哈希冲突的概率。代码简洁，符合现代编程的简洁性原则。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"依赖于特定的 .NET 版本（.NET Core 2.1 及以上），在旧版本的 .NET 环境中无法使用。对于一些特殊的哈希需求，可能无法进行定制化处理。"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"System.Tuple"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueTuple"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"简单易用，无需手动编写哈希码组合逻辑。能够自动处理多个属性的哈希码组合。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"可能会带来一些额外的性能开销，因为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Tuple"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueTuple"},{"Type":"NodeText","Data":"​ 是封装类型，存在一定的内存和性能消耗。在某些情况下，哈希码的分布可能不够均匀，仍然存在哈希冲突的风险。"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"自定义加权组合"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"可以根据属性的重要性或分布情况进行灵活调整，能够更好地满足特定的哈希需求。可以通过调整权重来优化哈希码的分布，减少哈希冲突。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"需要对属性的特点有深入的了解，权重的选择需要经过实验和调整，实现难度相对较高。代码复杂度较高，维护成本较大。"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"按位异或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"计算简单高效，位级操作速度快，不会带来过多性能开销。可将两个哈希码的位信息混合，使组合后的哈希码更均匀分布，降低哈希冲突概率。满足交换律，属性顺序不影响最终哈希码，保证一致性。"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"在某些特殊数据分布下，仍可能存在哈希冲突。对于哈希码相关性较强的数据，效果可能不佳。"}]}]}]},{"ID":"20250709021356-9wpozul","Type":"NodeParagraph","Properties":{"id":"20250709021356-9wpozul","updated":"20250709021356"}}]}