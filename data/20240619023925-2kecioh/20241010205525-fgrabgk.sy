{"ID":"20241010205525-fgrabgk","Spec":"2","Type":"NodeDocument","Properties":{"id":"20241010205525-fgrabgk","title":"C# 静态类和单例类","type":"doc","updated":"20241011002134"},"Children":[{"ID":"20241010205525-9h0thvz","Type":"NodeParagraph","Properties":{"id":"20241010205525-9h0thvz","updated":"20241010210016"},"Children":[{"Type":"NodeText","Data":"静态类和单例类在整个程序的生命周期中都只有一个，如果一个类在第一次使用时创建，在程序结束时销毁，那么将它设置为静态类或单例类在使用方面并没有太大区别。"}]},{"ID":"20241010210016-w8lnif3","Type":"NodeParagraph","Properties":{"id":"20241010210016-w8lnif3","updated":"20241010210016"}},{"ID":"20241010210018-p8cu0ma","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241010210018-p8cu0ma","updated":"20241010210045"},"Children":[{"Type":"NodeText","Data":"主要的区别："}]},{"ID":"20241010210033-nm89hr7","Type":"NodeParagraph","Properties":{"id":"20241010210033-nm89hr7","updated":"20241010210040"},"Children":[{"Type":"NodeText","Data":"在内存方面："}]},{"ID":"20241010210049-v1hrxdq","Type":"NodeParagraph","Properties":{"id":"20241010210049-v1hrxdq","updated":"20241010210752"},"Children":[{"Type":"NodeText","Data":"静态类不能创建实例，不会存放在GC堆中。单例类会创建一个实例放到GC堆中，同时将内存指针指向堆中实例的内存地址。"}]},{"ID":"20241010210758-hjz0f0a","Type":"NodeParagraph","Properties":{"id":"20241010210758-hjz0f0a","updated":"20241010210804"},"Children":[{"Type":"NodeText","Data":"在功能方面："}]},{"ID":"20241010210804-visy7hv","Type":"NodeParagraph","Properties":{"id":"20241010210804-visy7hv","updated":"20241010211213"},"Children":[{"Type":"NodeText","Data":"单例类是面向对象思想的，它拥有封装、继承、多态的特性，可以更灵活的扩展单例类。静态类不具有这些特性。"}]},{"ID":"20241010211217-sppc50u","Type":"NodeParagraph","Properties":{"id":"20241010211217-sppc50u","updated":"20241010211223"},"Children":[{"Type":"NodeText","Data":"在生命周期方面："}]},{"ID":"20241010211223-1uydv9c","Type":"NodeParagraph","Properties":{"id":"20241010211223-1uydv9c","updated":"20241010212126"},"Children":[{"Type":"NodeText","Data":"静态类的初始化过程是：静态字段初始化-\u003e静态构造初始化。如果静态字段有默认值，那么字段会在程序一开始就初始化，同时因为静态类中的成员被调用，所以整个静态类被初始化。如果字段没有默认值，那么静态类会在类内成员或类方法第一次被调用的时候初始化。初始化后的静态类不受GC的控制，会一直到程序结束时才会释放。"}]},{"ID":"20241010211750-uwswvs4","Type":"NodeParagraph","Properties":{"id":"20241010211750-uwswvs4","updated":"20241010212630"},"Children":[{"Type":"NodeText","Data":"单例类有饿汉式和懒汉式，饿汉式在程序一开始就初始化（类似静态类有初始值），懒汉式在第一次调用时初始化（类似静态类没有初始值）。但是单例类可以由程序员手动控制生命周期，提前释放。一般单例都使用懒汉式，因此也可以达到延迟初始化的效果。在游戏开发中，很多类只需要在某个阶段存在一个实例，那么可以使用单例类，需要的时候创建，不需要的时候销毁，相比静态类只能创建不能销毁更灵活。"}]},{"ID":"20241010212854-sxiv4ur","Type":"NodeParagraph","Properties":{"id":"20241010212854-sxiv4ur","updated":"20241010213700"},"Children":[{"Type":"NodeText","Data":"在多线程安全方面："}]},{"ID":"20241010213700-px0l3f5","Type":"NodeParagraph","Properties":{"id":"20241010213700-px0l3f5","updated":"20241010213832"},"Children":[{"Type":"NodeText","Data":"单例类可以更方便的实现多线程安全，因为它是对象级别的，只需要对这个单例类的实例加锁即可。但是静态类需要给每一个方法都加锁。"}]},{"ID":"20241010212855-p4xr6gh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241010212855-p4xr6gh","updated":"20241010212858"},"Children":[{"Type":"NodeText","Data":"参考"}]},{"ID":"20241010212902-ivv8r9m","Type":"NodeParagraph","Properties":{"id":"20241010212902-ivv8r9m","updated":"20241010212916"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://masuit.net/1204?t=0HN70DKJCFU68","TextMarkTextContent":"谈一谈单例模式、静态类和线程内唯一对象有什么区别_懒得勤快的博客_互联网分享精神 (masuit.net)"}]}]}