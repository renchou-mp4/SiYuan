{"ID":"20250813171618-wj10hux","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250813171618-wj10hux","title":"C# 使用Variable来替代object","type":"doc","updated":"20250813173440"},"Children":[{"ID":"20250813171618-57qngp5","Type":"NodeParagraph","Properties":{"id":"20250813171618-57qngp5","updated":"20250813172014"},"Children":[{"Type":"NodeText","Data":"使用Variable的主要目的是为了实现：1、类型安全 2、统一操作 3、复用，而这些作用都是object所不具有的。"}]},{"ID":"20250813172014-92e7052","Type":"NodeParagraph","Properties":{"id":"20250813172014-92e7052","updated":"20250813172618"},"Children":[{"Type":"NodeText","Data":"Variable是基类，由Variable\u003cT\u003e继承并实现，而VarInt，VarDouble，VarChar则继承Variable\u003cT\u003e，具体实现各自的类型。"}]},{"ID":"20250813172015-v1f9fft","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250813172015-v1f9fft","updated":"20250813172942"},"Children":[{"Type":"NodeText","Data":"一、类型安全"}]},{"ID":"20250813172030-7q2re7c","Type":"NodeParagraph","Properties":{"id":"20250813172030-7q2re7c","updated":"20250813172242"},"Children":[{"Type":"NodeText","Data":"在存储数据的时候，如果使用object，就会有类型转换的问题，如果不注意很可能会导致类型不匹配。而object在代码编译的时候是无法检查类型是否安全的。"}]},{"ID":"20250813172244-chq39z6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250813172244-chq39z6","updated":"20250813172348"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"QyM="},{"Type":"NodeCodeBlockCode","Data":"// 传统方式：用 object 存储，操作时需频繁强制转换\nDictionary\u003cstring, object\u003e dataNodes = new Dictionary\u003cstring, object\u003e();\ndataNodes[\"PlayerGold\"] = 1000;       // 存 int\ndataNodes[\"PlayerName\"] = \"张三\";     // 存 string\n\n// 读取时需手动转换，且可能因类型错误崩溃\nint gold = (int)dataNodes[\"PlayerGold\"];       // 若实际是 string 则抛异常\nstring name = (string)dataNodes[\"PlayerName\"]; // 类型不匹配风险高\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250813171952-8bzdnts","Type":"NodeParagraph","Properties":{"id":"20250813171952-8bzdnts","updated":"20250813172642"},"Children":[{"Type":"NodeText","Data":"使用Variable时："}]},{"ID":"20250813172643-knihn35","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250813172643-knihn35","updated":"20250813172659"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"QyM="},{"Type":"NodeCodeBlockCode","Data":"// 1. 定义具体类型的 Variable\npublic class IntVariable : Variable\u003cint\u003e { }\npublic class StringVariable : Variable\u003cstring\u003e { }\n\n// 2. 存储数据：类型明确，无需装箱\nIntVariable goldVar = ReferencePool.Acquire\u003cIntVariable\u003e();\ngoldVar.Value = 1000;\ndataNodeManager.SetData(\"Player/Gold\", goldVar); // 调用 SetData\u003cT\u003e(T data)\n\nStringVariable nameVar = ReferencePool.Acquire\u003cStringVariable\u003e();\nnameVar.Value = \"张三\";\ndataNodeManager.SetData(\"Player/Name\", nameVar);\n\n// 3. 读取数据：直接获取对应类型，避免转换错误\nIntVariable getGoldVar = dataNodeManager.GetData\u003cIntVariable\u003e(\"Player/Gold\");\nint gold = getGoldVar.Value; // 直接访问，类型安全\n\nStringVariable getNameVar = dataNodeManager.GetData\u003cStringVariable\u003e(\"Player/Name\");\nstring name = getNameVar.Value; // 无强制转换，编译时检查类型\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250813172649-v6lqo8z","Type":"NodeParagraph","Properties":{"id":"20250813172649-v6lqo8z","updated":"20250813172923"},"Children":[{"Type":"NodeText","Data":"在读取数据的时候，可以直接指定要读取的类型，代码编译的时候可以检查是否匹配。"}]},{"ID":"20250813172936-h1ilicm","Type":"NodeParagraph","Properties":{"id":"20250813172936-h1ilicm","updated":"20250813172936"}},{"ID":"20250813172937-zuq1aan","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250813172937-zuq1aan","updated":"20250813173307"},"Children":[{"Type":"NodeText","Data":"二、统一操作"}]},{"ID":"20250813172956-glxwaac","Type":"NodeParagraph","Properties":{"id":"20250813172956-glxwaac","updated":"20250813173306"},"Children":[{"Type":"NodeText","Data":"如上代码使用object时需要将储存的值转换为对应的类型，使用Variable时因为有统一的SetData和GetData，因此无需考虑具体的转换直接调用接口即可，类型清晰且操作统一。"}]},{"ID":"20250813173307-ip5qhh0","Type":"NodeParagraph","Properties":{"id":"20250813173307-ip5qhh0","updated":"20250813173307"}},{"ID":"20250813173307-am9hy8f","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250813173307-am9hy8f","updated":"20250813173440"},"Children":[{"Type":"NodeText","Data":"三、复用"}]},{"ID":"20250813173317-atijldp","Type":"NodeParagraph","Properties":{"id":"20250813173317-atijldp","updated":"20250813173440"},"Children":[{"Type":"NodeText","Data":"使用object，若需要存储的值需要反复生成和销毁，那么可能会产生较大的GC压力。Variable内置实现了引用池，可以复用Variable对象，减小GC压力。"}]},{"ID":"20250813173220-ihwi4hb","Type":"NodeParagraph","Properties":{"id":"20250813173220-ihwi4hb","updated":"20250813173220"}}]}