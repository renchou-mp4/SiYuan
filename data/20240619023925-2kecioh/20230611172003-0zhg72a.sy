{"ID":"20230611172003-0zhg72a","Spec":"2","Type":"NodeDocument","Properties":{"id":"20230611172003-0zhg72a","title":"C# List底层源码","type":"doc","updated":"20230519152338"},"Children":[{"ID":"20230611172003-70mhcpm","Type":"NodeParagraph","Properties":{"id":"20230611172003-70mhcpm","updated":"20230519144947"},"Children":[{"Type":"NodeText","Data":"List，即可变数组，通常用来代替数组。"}]},{"ID":"20230611172003-e5f1zny","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-e5f1zny","updated":"20230519144742"},"Children":[{"Type":"NodeText","Data":"构造"}]},{"ID":"20230611172003-vlqfmuj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-vlqfmuj","updated":"20230519144756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"public class List\u003cT\u003e : IList\u003cT\u003e, System.Collections.IList, IReadOnlyList\u003cT\u003e\n{\n    private const int _defaultCapacity = 4;\n\n    private T[] _items;\n    private int _size;\n    private int _version;\n    private Object _syncRoot;\n  \n    static readonly T[]  _emptyArray = new T[0];    \n    \n    // Constructs a List. The list is initially empty and has a capacity\n    // of zero. Upon adding the first element to the list the capacity is\n    // increased to 16, and then increased in multiples of two as required.\n    public List() {\n        _items = _emptyArray;\n    }\n\n    // Constructs a List with a given initial capacity. The list is\n    // initially empty, but will have room for the given number of elements\n    // before any reallocations are required.\n    // \n    public List(int capacity) {\n        if (capacity \u003c 0) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n        Contract.EndContractBlock();\n\n        if (capacity == 0)\n            _items = _emptyArray;\n        else\n            _items = new T[capacity];\n    }\n\n    //...\n    //其他内容\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-csqnxax","Type":"NodeParagraph","Properties":{"id":"20230611172003-csqnxax","updated":"20230519145116"},"Children":[{"Type":"NodeText","Data":"List"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"底层"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"是用数组实现的。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color12);"},"TextMarkType":"strong text","TextMarkTextContent":"若不指定List的容量，那么默认大小为0。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color12);\"}"}]},{"ID":"20230611172003-6hnc01x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-6hnc01x","updated":"20230516105807"},"Children":[{"Type":"NodeText","Data":"Add"}]},{"ID":"20230611172003-3ldi1zw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-3ldi1zw","updated":"20230519145522"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// Adds the given object to the end of this list. The size of the list is\n// increased by one. If required, the capacity of the list is doubled\n// before adding the new element.\n//\npublic void Add(T item) {\n    if (_size == _items.Length) EnsureCapacity(_size + 1);\n    _items[_size++] = item;\n    _version++;\n}\n\n// Ensures that the capacity of this list is at least the given minimum\n// value. If the currect capacity of the list is less than min, the\n// capacity is increased to twice the current capacity or to min,\n// whichever is larger.\nprivate void EnsureCapacity(int min) {\n    if (_items.Length \u003c min) {\n        int newCapacity = _items.Length == 0? _defaultCapacity : _items.Length * 2;\n        // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.\n        // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n        if ((uint)newCapacity \u003e Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;\n        if (newCapacity \u003c min) newCapacity = min;\n        Capacity = newCapacity;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-tuojica","Type":"NodeParagraph","Properties":{"id":"20230611172003-tuojica","updated":"20230519145336"},"Children":[{"Type":"NodeText","Data":"在Add之前会使用EnsureCapacity来确定空间大小，保证空间充足。\n每次容量不够的时候，整个数组会扩容一倍。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color12);"},"TextMarkType":"strong text","TextMarkTextContent":"当Add新数据时，若容量大小为默认的0，则扩容_defaultCapacity=4个空间"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color12);\"}"},{"Type":"NodeText","Data":"，因此扩容的时候容量依次是4，8，16，32......"}]},{"ID":"20230611172003-fzqw7ai","Type":"NodeParagraph","Properties":{"id":"20230611172003-fzqw7ai","updated":"20230519145807"},"Children":[{"Type":"NodeText","Data":"List使用数组作为底层数据结构，因此可以使用索引方式很快的提取元素。但在扩容的时候，每次new数组都会造成内存垃圾，给GC带来了很多负担。且若数量不得当可能会造成空间的浪费，例如只需要520个空间，但是List会扩容到1024，剩下的空间就浪费掉了。因此在使用List的时候，如果可以得到List的最大容量，可以在初始化的时候直接初始化容量，避免反复创建数组和容量浪费。"}]},{"ID":"20230611172003-fezpp3e","Type":"NodeParagraph","Properties":{"id":"20230611172003-fezpp3e"}},{"ID":"20230611172003-at9p859","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-at9p859","updated":"20230516214814"},"Children":[{"Type":"NodeText","Data":"Remove"}]},{"ID":"20230611172003-2udg2co","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-2udg2co","updated":"20230519145827"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// Removes the element at the given index. The size of the list is\n// decreased by one.\n// \npublic bool Remove(T item) {\n    int index = IndexOf(item);\n    if (index \u003e= 0) {\n        RemoveAt(index);\n        return true;\n    }\n\n    return false;\n}\n\n// Returns the index of the first occurrence of a given value in a range of\n// this list. The list is searched forwards from beginning to end.\n// The elements of the list are compared to the given value using the\n// Object.Equals method.\n// \n// This method uses the Array.IndexOf method to perform the\n// search.\n// \npublic int IndexOf(T item) {\n    Contract.Ensures(Contract.Result\u003cint\u003e() \u003e= -1);\n    Contract.Ensures(Contract.Result\u003cint\u003e() \u003c Count);\n    return Array.IndexOf(_items, item, 0, _size);\n}\n\n// Removes the element at the given index. The size of the list is\n// decreased by one.\n// \npublic void RemoveAt(int index) {\n    if ((uint)index \u003e= (uint)_size) {\n        ThrowHelper.ThrowArgumentOutOfRangeException();\n    }\n    Contract.EndContractBlock();\n    _size--;\n    if (index \u003c _size) {\n        Array.Copy(_items, index + 1, _items, index, _size - index);\n    }\n    _items[_size] = default(T);\n    _version++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-gfkxfvs","Type":"NodeParagraph","Properties":{"id":"20230611172003-gfkxfvs","updated":"20230519150145"},"Children":[{"Type":"NodeText","Data":"元素删除就是使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Array.Copy(_items, index + 1, _items, index, _size - index);"},{"Type":"NodeText","Data":"​对元素进行覆盖。"}]},{"ID":"20230611172003-azqghwg","Type":"NodeParagraph","Properties":{"id":"20230611172003-azqghwg","updated":"20230519150344"},"Children":[{"Type":"NodeText","Data":"IndexOf使用的是Array.IndexOf接口来查找元素的下标，这个接口内部就是从0开始依次比较，复杂度为O(n)。"}]},{"ID":"20230611172003-kkd415x","Type":"NodeParagraph","Properties":{"id":"20230611172003-kkd415x"}},{"ID":"20230611172003-1zmewnj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-1zmewnj","updated":"20230519150407"},"Children":[{"Type":"NodeText","Data":"Insert"}]},{"ID":"20230611172003-zf9iinv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-zf9iinv","updated":"20230519150430"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// Inserts an element into this list at a given index. The size of the list\n// is increased by one. If required, the capacity of the list is doubled\n// before inserting the new element.\n// \npublic void Insert(int index, T item) {\n    // Note that insertions at the end are legal.\n    if ((uint) index \u003e (uint)_size) {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);\n    }\n    Contract.EndContractBlock();\n    if (_size == _items.Length) EnsureCapacity(_size + 1);\n    if (index \u003c _size) {\n        Array.Copy(_items, index, _items, index + 1, _size - index);\n    }\n    _items[index] = item;\n    _size++;          \n    _version++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-effbu8r","Type":"NodeParagraph","Properties":{"id":"20230611172003-effbu8r","updated":"20230519150707"},"Children":[{"Type":"NodeText","Data":"插入也是使用Array.Copy将数组中指定元素后面的元素向后移动一个位置。"}]},{"ID":"20230611172003-hqh9jpy","Type":"NodeParagraph","Properties":{"id":"20230611172003-hqh9jpy"}},{"ID":"20230611172003-5bhe5qn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-5bhe5qn","updated":"20230519151629"},"Children":[{"Type":"NodeText","Data":"索引"}]},{"ID":"20230611172003-0fa48m8","Type":"NodeParagraph","Properties":{"id":"20230611172003-0fa48m8","updated":"20230516215030"},"Children":[{"Type":"NodeText","Data":"直接数组下标访问"}]},{"ID":"20230611172003-ozp753x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-ozp753x","updated":"20230519151524"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"// Sets or Gets the element at the given index.\n// \npublic T this[int index] {\n    get {\n        // Following trick can reduce the range check by one\n        if ((uint) index \u003e= (uint)_size) {\n            ThrowHelper.ThrowArgumentOutOfRangeException();\n        }\n        Contract.EndContractBlock();\n        return _items[index]; \n    }\n\n    set {\n        if ((uint) index \u003e= (uint)_size) {\n            ThrowHelper.ThrowArgumentOutOfRangeException();\n        }\n        Contract.EndContractBlock();\n        _items[index] = value;\n        _version++;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-5vswqka","Type":"NodeParagraph","Properties":{"id":"20230611172003-5vswqka","updated":"20230519151651"},"Children":[{"Type":"NodeText","Data":"[]的实现，直接使用的数组的索引获取元素。"}]},{"ID":"20230611172003-bx5niim","Type":"NodeParagraph","Properties":{"id":"20230611172003-bx5niim"}},{"ID":"20230611172003-a2nusgy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-a2nusgy","updated":"20230516215043"},"Children":[{"Type":"NodeText","Data":"Clear"}]},{"ID":"20230611172003-bv9s32j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-bv9s32j","updated":"20230519151704"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3NoYXJw"},{"Type":"NodeCodeBlockCode","Data":"// Clears the contents of List.\npublic void Clear() {\n    if (_size \u003e 0)\n    {\n        Array.Clear(_items, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.\n        _size = 0;\n    }\n    _version++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-tmnstd9","Type":"NodeParagraph","Properties":{"id":"20230611172003-tmnstd9","updated":"20230519151712"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color12);"},"TextMarkType":"text strong","TextMarkTextContent":"Clear接口在调用时并不会删除数组，而只是将数组中的元素清零，并设置 _size 为 0 而已"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color12);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230611172003-ib0l332","Type":"NodeParagraph","Properties":{"id":"20230611172003-ib0l332"}},{"ID":"20230611172003-4avq3u8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-4avq3u8","updated":"20230519151805"},"Children":[{"Type":"NodeText","Data":"Contains"}]},{"ID":"20230611172003-f9rjygf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-f9rjygf","updated":"20230519151807"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// Contains returns true if the specified element is in the List.\n// It does a linear, O(n) search.  Equality is determined by calling\n// item.Equals().\n//\npublic bool Contains(T item) {\n    if ((Object) item == null) {\n        for(int i=0; i\u003c_size; i++)\n            if ((Object) _items[i] == null)\n                return true;\n        return false;\n    }\n    else {\n        EqualityComparer\u003cT\u003e c = EqualityComparer\u003cT\u003e.Default;\n        for(int i=0; i\u003c_size; i++) {\n            if (c.Equals(_items[i], item)) return true;\n        }\n        return false;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-pivnqc7","Type":"NodeParagraph","Properties":{"id":"20230611172003-pivnqc7","updated":"20230519151911"},"Children":[{"Type":"NodeText","Data":"Contains使用的是线性查找方式，复杂度O(n)"}]},{"ID":"20230611172003-07ha7rj","Type":"NodeParagraph","Properties":{"id":"20230611172003-07ha7rj"}},{"ID":"20230611172003-bkhfyz9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-bkhfyz9","updated":"20230519151921"},"Children":[{"Type":"NodeText","Data":"ToArray"}]},{"ID":"20230611172003-yohwnnx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-yohwnnx","updated":"20230519151925"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// ToArray returns a new Object array containing the contents of the List.\n// This requires copying the List, which is an O(n) operation.\npublic T[] ToArray() {\n    Contract.Ensures(Contract.Result\u003cT[]\u003e() != null);\n    Contract.Ensures(Contract.Result\u003cT[]\u003e().Length == Count);\n\n    T[] array = new T[_size];\n    Array.Copy(_items, 0, array, 0, _size);\n    return array;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-rwalyla","Type":"NodeParagraph","Properties":{"id":"20230611172003-rwalyla","updated":"20230519152018"},"Children":[{"Type":"NodeText","Data":"ToArray中重新new了一个指定大小的数组，再将原来的数组拷贝到新数组上来。"}]},{"ID":"20230611172003-k88zm7a","Type":"NodeParagraph","Properties":{"id":"20230611172003-k88zm7a"}},{"ID":"20230611172003-tchhj0v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-tchhj0v","updated":"20230519152113"},"Children":[{"Type":"NodeText","Data":"Find"}]},{"ID":"20230611172003-3k0hojf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-3k0hojf","updated":"20230519152114"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"public T Find(Predicate\u003cT\u003e match) {\n    if( match == null) {\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match);\n    }\n    Contract.EndContractBlock();\n\n    for(int i = 0 ; i \u003c _size; i++) {\n        if(match(_items[i])) {\n            return _items[i];\n        }\n    }\n    return default(T);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-00brbid","Type":"NodeParagraph","Properties":{"id":"20230611172003-00brbid","updated":"20230519152141"},"Children":[{"Type":"NodeText","Data":"Find接口也是线性查找，复杂度O(n)。"}]},{"ID":"20230611172003-zvx15qx","Type":"NodeParagraph","Properties":{"id":"20230611172003-zvx15qx"}},{"ID":"20230611172003-n4l92i9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-n4l92i9","updated":"20230516215053"},"Children":[{"Type":"NodeText","Data":"Sort"}]},{"ID":"20230611172003-vav34fl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-vav34fl","updated":"20230519152207"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"// Sorts the elements in a section of this list. The sort compares the\n// elements to each other using the given IComparer interface. If\n// comparer is null, the elements are compared to each other using\n// the IComparable interface, which in that case must be implemented by all\n// elements of the list.\n// \n// This method uses the Array.Sort method to sort the elements.\n// \npublic void Sort(int index, int count, IComparer\u003cT\u003e comparer) {\n    if (index \u003c 0) {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n    }\n  \n    if (count \u003c 0) {\n        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);\n    }\n    \n    if (_size - index \u003c count)\n        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_InvalidOffLen);\n    Contract.EndContractBlock();\n\n    Array.Sort\u003cT\u003e(_items, index, count, comparer);\n    _version++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-dhd7328","Type":"NodeParagraph","Properties":{"id":"20230611172003-dhd7328","updated":"20230519152310"},"Children":[{"Type":"NodeText","Data":"List的Sort接口使用的是Array.Sort。Array.Sort源码如下"}]},{"ID":"20230611172003-4cp5ij3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20230611172003-4cp5ij3","updated":"20230519152254"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YyM="},{"Type":"NodeCodeBlockCode","Data":"internal static void DepthLimitedQuickSort(T[] keys, int left, int right, IComparer\u003cT\u003e comparer, int depthLimit)\n{\n    do\n    {\n        if (depthLimit == 0)\n        {\n            Heapsort(keys, left, right, comparer);\n            return;\n        }\n\n        int i = left;\n        int j = right;\n\n        // pre-sort the low, middle (pivot), and high values in place.\n        // this improves performance in the face of already sorted data, or \n        // data that is made up of multiple sorted runs appended together.\n        int middle = i + ((j - i) \u003e\u003e 1);\n        SwapIfGreater(keys, comparer, i, middle);  // swap the low with the mid point\n        SwapIfGreater(keys, comparer, i, j);   // swap the low with the high\n        SwapIfGreater(keys, comparer, middle, j); // swap the middle with the high\n\n        T x = keys[middle];\n        do\n        {\n            while (comparer.Compare(keys[i], x) \u003c 0) i++;\n            while (comparer.Compare(x, keys[j]) \u003c 0) j--;\n            Contract.Assert(i \u003e= left \u0026\u0026 j \u003c= right, \"(i\u003e=left \u0026\u0026 j\u003c=right)  Sort failed - Is your IComparer bogus?\");\n            if (i \u003e j) break;\n            if (i \u003c j)\n            {\n                T key = keys[i];\n                keys[i] = keys[j];\n                keys[j] = key;\n            }\n            i++;\n            j--;\n        } while (i \u003c= j);\n\n        // The next iteration of the while loop is to \"recursively\" sort the larger half of the array and the\n        // following calls recrusively sort the smaller half.  So we subtrack one from depthLimit here so\n        // both sorts see the new value.\n        depthLimit--;\n\n        if (j - left \u003c= right - i)\n        {\n            if (left \u003c j) DepthLimitedQuickSort(keys, left, j, comparer, depthLimit);\n            left = i;\n        }\n        else\n        {\n            if (i \u003c right) DepthLimitedQuickSort(keys, i, right, comparer, depthLimit);\n            right = j;\n        }\n    } while (left \u003c right);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20230611172003-h68hwdu","Type":"NodeParagraph","Properties":{"id":"20230611172003-h68hwdu"},"Children":[{"Type":"NodeText","Data":"Array.Sort 使用的是快速排序方式进行排序，从而我们明白了 List 的 Sort 排序的效率为O(nlogn)。"}]},{"ID":"20230611172003-lznuft9","Type":"NodeParagraph","Properties":{"id":"20230611172003-lznuft9"}},{"ID":"20230611172003-vze7dki","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-vze7dki","updated":"20230516215056"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20230611172003-tq2yr9x","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20230611172003-tq2yr9x","updated":"20230519152338"},"Children":[{"ID":"20230611172003-ydmuowx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20230611172003-ydmuowx","updated":"20230519152338"},"Children":[{"ID":"20230611172003-h5pz2wa","Type":"NodeParagraph","Properties":{"id":"20230611172003-h5pz2wa","updated":"20230519153013"},"Children":[{"Type":"NodeText","Data":"List的效率并不高，只是通用性强，大部分的算法都使用的是线性复杂度算法，当这些接口被频繁调用的时候就会有较大的CPU消耗。可以自己再封装一下，将原来线性算法的接口替换。"}]}]},{"ID":"20230611172003-wek6cwh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20230611172003-wek6cwh"},"Children":[{"ID":"20230611172003-prthjfl","Type":"NodeParagraph","Properties":{"id":"20230611172003-prthjfl"},"Children":[{"Type":"NodeText","Data":"List的元素在不断增加时，会多次重新new数组，导致原来的数组被抛弃，增加GC的压力。使用List的时候，如果能提前知道List的最大容量，可以直接在初始化的时候初始化容量。"}]}]},{"ID":"20230611172003-daruxx4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20230611172003-daruxx4"},"Children":[{"ID":"20230611172003-121ir0f","Type":"NodeParagraph","Properties":{"id":"20230611172003-121ir0f"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color12);"},"TextMarkType":"strong text","TextMarkTextContent":"代码是线程不安全的，它并没有对多线程下做任何锁或其他同步操作。并发情况下，无法判断 _size++ 的执行顺序，因此当我们在多线程间使用 List 时加上安全机制。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color12);\"}"}]}]},{"ID":"20230611172003-ed8glyr","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20230611172003-ed8glyr"},"Children":[{"ID":"20230611172003-ul5eoun","Type":"NodeParagraph","Properties":{"id":"20230611172003-ul5eoun","updated":"20230519152939"},"Children":[{"Type":"NodeText","Data":"foreach已在Unity5.5修复，不再会产生多余的GC。之前是因为foreach会不断new一个Enumerator实例。"}]}]}]},{"ID":"20230611172003-x9vphv6","Type":"NodeParagraph","Properties":{"id":"20230611172003-x9vphv6"}},{"ID":"20230611172003-gy6biyc","Type":"NodeParagraph","Properties":{"id":"20230611172003-gy6biyc"}},{"ID":"20230611172003-s9y0ear","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230611172003-s9y0ear","updated":"20230519114422"},"Children":[{"Type":"NodeText","Data":"参考"}]},{"ID":"20230611172003-8hzmvgy","Type":"NodeParagraph","Properties":{"id":"20230611172003-8hzmvgy","updated":"20230519114426"},"Children":[{"Type":"NodeText","Data":"1、"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/279165656","TextMarkTextContent":"【C"},{"Type":"NodeTextMark","TextMarkType":"a tag","TextMarkAHref":"https://zhuanlan.zhihu.com/p/279165656","TextMarkTextContent":"】浅析C"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://zhuanlan.zhihu.com/p/279165656","TextMarkTextContent":" List实现原理 - 知乎 (zhihu.com)"}]},{"ID":"20230611172003-rllfmwj","Type":"NodeParagraph","Properties":{"id":"20230611172003-rllfmwj","updated":"20230519144452"},"Children":[{"Type":"NodeText","Data":"2、"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://www.luzexi.com/2018/07/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF1","TextMarkTextContent":"《Unity3D高级编程之进阶主程》第一章，C#要点技术(一) - List 底层源码剖析 - 技术人生 (luzexi.com)"}]},{"ID":"20230611172003-dojc0h8","Type":"NodeParagraph","Properties":{"id":"20230611172003-dojc0h8"}}]}