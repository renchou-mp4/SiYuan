{"ID":"20240304164245-rmoveld","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240304164245-rmoveld","title":"SML","type":"doc","updated":"20240401094305"},"Children":[{"ID":"20240304164245-ixkksge","Type":"NodeParagraph","Properties":{"id":"20240304164245-ixkksge","updated":"20240304164308"},"Children":[{"Type":"NodeText","Data":"环境："}]},{"ID":"20240304164308-b769x60","Type":"NodeParagraph","Properties":{"id":"20240304164308-b769x60","updated":"20240304164400"},"Children":[{"Type":"NodeText","Data":"VScode+SML Environment插件"}]},{"ID":"20240304164400-kwwbk5s","Type":"NodeParagraph","Properties":{"id":"20240304164400-kwwbk5s","updated":"20240304164637"},"Children":[{"Type":"NodeText","Data":"SML/NJ 110.80"}]},{"ID":"20240304164640-7lktcop","Type":"NodeParagraph","Properties":{"id":"20240304164640-7lktcop","updated":"20240304164640"}},{"ID":"20240304164643-o9lah14","Type":"NodeParagraph","Properties":{"id":"20240304164643-o9lah14","updated":"20240304164651"},"Children":[{"Type":"NodeText","Data":"安装："}]},{"ID":"20240304164651-zg31bv5","Type":"NodeParagraph","Properties":{"id":"20240304164651-zg31bv5","updated":"20240304164757"},"Children":[{"Type":"NodeText","Data":"SML/NJ安装后会自动配置环境变量，重启电脑生效，否则可能会检测不到sml命令。"}]},{"ID":"20240304164759-vpf7j7r","Type":"NodeParagraph","Properties":{"id":"20240304164759-vpf7j7r","updated":"20240304164824"},"Children":[{"Type":"NodeText","Data":"SML Environment插件安装后重启VScode。"}]},{"ID":"20240304164829-836k8rv","Type":"NodeParagraph","Properties":{"id":"20240304164829-836k8rv","updated":"20240304164829"}},{"ID":"20240304164829-1juefyo","Type":"NodeParagraph","Properties":{"id":"20240304164829-1juefyo","updated":"20240304164832"},"Children":[{"Type":"NodeText","Data":"使用："}]},{"ID":"20240304164832-89vbuu6","Type":"NodeParagraph","Properties":{"id":"20240304164832-89vbuu6","updated":"20240304170201"},"Children":[{"Type":"NodeText","Data":"打开sml文件，编写代码，保存。"}]},{"ID":"20240304170202-qalq2lo","Type":"NodeParagraph","Properties":{"id":"20240304170202-qalq2lo","updated":"20240304170256"},"Children":[{"Type":"NodeText","Data":"Ctrl + Shift + U打开VScode的Output窗口，选择TERMINAL页签，cd到该sml文件的位置。"}]},{"ID":"20240304170257-3a9g0yw","Type":"NodeParagraph","Properties":{"id":"20240304170257-3a9g0yw","updated":"20240304170351"},"Children":[{"Type":"NodeText","Data":"输入sml，进入sml模式，输入use命令即可读取到对应文件."}]},{"ID":"20240304170402-tsc5ixn","Type":"NodeParagraph","Properties":{"id":"20240304170402-tsc5ixn","updated":"20240304170402"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240304170402-41so9en.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240304205724-khkbppm","Type":"NodeParagraph","Properties":{"id":"20240304205724-khkbppm"}},{"ID":"20240304205728-3nlzr6v","Type":"NodeParagraph","Properties":{"id":"20240304205728-3nlzr6v","updated":"20240304205728"}},{"ID":"20240304205728-pewgjdi","Type":"NodeParagraph","Properties":{"id":"20240304205728-pewgjdi","updated":"20240304205728"}},{"ID":"20240304205728-z40g0jx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240304205728-z40g0jx","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"ML变量绑定和表达式"}]},{"ID":"20240304205743-z6gfbdi","Type":"NodeParagraph","Properties":{"id":"20240304205743-z6gfbdi","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"类型检查发生在程序运行前，它会拓展静态环境。类型检查时，只会检查类型是否正确，不管具体的值。例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val x = 17;"},{"Type":"NodeText","Data":"​静态环境记录为x --\u003e int。"}]},{"ID":"20240304210530-zfu3n6f","Type":"NodeParagraph","Properties":{"id":"20240304210530-zfu3n6f","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"程序在运行时会拓展动态环境，从前向后执行，每执行一句绑定语句"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val y = 34;"},{"Type":"NodeText","Data":"​就会将动态环境拓展。"}]},{"ID":"20240304210727-nyk1az5","Type":"NodeParagraph","Properties":{"id":"20240304210727-nyk1az5","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"静态环境和动态环境都一样，如果某个表达式"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"z = x + y"},{"Type":"NodeText","Data":"​出现在x或y的绑定语句前，就会报错。因为程序是从前向后读取，在碰到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"z = x + y"},{"Type":"NodeText","Data":"​时，x或y并不在环境中。"}]},{"ID":"20240305204654-ek32hlm","Type":"NodeParagraph","Properties":{"id":"20240305204654-ek32hlm","updated":"20240314112931"}},{"ID":"20240305204657-wvrfkc6","Type":"NodeParagraph","Properties":{"id":"20240305204657-wvrfkc6","updated":"20240314112931"}},{"ID":"20240305204657-z93xbtg","Type":"NodeParagraph","Properties":{"id":"20240305204657-z93xbtg","updated":"20240314112931"}},{"ID":"20240305204657-sf02j5d","Type":"NodeParagraph","Properties":{"id":"20240305204657-sf02j5d","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"ML一些语法问题"}]},{"ID":"20240305204717-z5paiv1","Type":"NodeParagraph","Properties":{"id":"20240305204717-z5paiv1","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"1、ML如果使用if语句，则必须写全if/then/else，三个关键字都不能省略。"}]},{"ID":"20240305204800-h6j8s9o","Type":"NodeParagraph","Properties":{"id":"20240305204800-h6j8s9o","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"2、ML如果要新建一个值，必须在名称前面再加上val，否则编译器会将表达式算成是上一行的一部分。"}]},{"ID":"20240305204936-r1rbg5f","Type":"NodeParagraph","Properties":{"id":"20240305204936-r1rbg5f","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"3、ML在表示一个负数时使用~，即"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val x = ~5"},{"Type":"NodeText","Data":"​。在进行运算的时候使用-号。"}]},{"ID":"20240305205301-mqar798","Type":"NodeParagraph","Properties":{"id":"20240305205301-mqar798","updated":"20240314112931"},"Children":[{"Type":"NodeText","Data":"4、ML中对整数（int类型）使用除法时必须使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"div"},{"Type":"NodeText","Data":"​，例如："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val x = 5 div 6"},{"Type":"NodeText","Data":"​，两个操作数都必须都为int才能，若其中一个为浮点数（real类型）就会报错。\n对浮点数使用除法时必须使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"/"},{"Type":"NodeText","Data":"​，例如："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"val y = 1.5 / 2.5"},{"Type":"NodeText","Data":"​。两个操作数都必须为real才可以。"}]},{"ID":"20240305211608-hu6vbse","Type":"NodeParagraph","Properties":{"id":"20240305211608-hu6vbse","updated":"20240314112931"}},{"ID":"20240305211609-zxmn30t","Type":"NodeParagraph","Properties":{"id":"20240305211609-zxmn30t","updated":"20240314112931"}},{"ID":"20240305211609-9049ej6","Type":"NodeParagraph","Properties":{"id":"20240305211609-9049ej6","updated":"20240314112931"}},{"ID":"20240305211610-3j6ilic","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240305211610-3j6ilic","updated":"20240314112947"},"Children":[{"Type":"NodeText","Data":"ML的Shadow概念"}]},{"ID":"20240305211624-t4shhvu","Type":"NodeParagraph","Properties":{"id":"20240305211624-t4shhvu","updated":"20240314112947"},"Children":[{"Type":"NodeText","Data":"在ML中读取文件中的语句是从前到后的，如果在一个文件中一个val被绑定了多次，那么前面的val就会被Shadowed。"}]},{"ID":"20240305212158-k76bbvc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240305212158-k76bbvc","style":"line-height: 22px;","updated":"20240314112947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*注释为动态环境*)\nval a = 1;\n(* a -\u003e 1 *)\nval b = a * 2;\n(* a -\u003e 1, b -\u003e 2, 此时b已经完成了绑定，与a就没有关系了*)\nval a = a + 1;\n(* a -\u003e 2, b -\u003e 2, 这时前面的a就被屏蔽了，下面再在动态环境读取a时读到的就是2了，而且b不受影响，仍然是2*)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240305213656-8ypmucv","Type":"NodeParagraph","Properties":{"id":"20240305213656-8ypmucv","updated":"20240314112947"}},{"ID":"20240306205120-8yaf9f8","Type":"NodeParagraph","Properties":{"id":"20240306205120-8yaf9f8","updated":"20240314112947"}},{"ID":"20240306205120-r40mgnc","Type":"NodeParagraph","Properties":{"id":"20240306205120-r40mgnc","updated":"20240314112947"}},{"ID":"20240306205122-0st13so","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240306205122-0st13so","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"ML的函数"}]},{"ID":"20240306205143-pggn131","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240306205143-pggn131","style":"line-height: 22px;","updated":"20240314112949"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"fun pow( x : int, y : int)=\n    if y = 0\n    then 1\n    else x * pow( x, y - 1);\n\npow(4,3);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240306205155-zmjr5sk","Type":"NodeParagraph","Properties":{"id":"20240306205155-zmjr5sk","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"ML的函数不加{ }，在else的结尾添加分号会减少歧义（上面的代码如果不加，会将x * pow( x, y - 1)pow(4,3)算作一整个表达式）"}]},{"ID":"20240306205350-c6ytwv2","Type":"NodeParagraph","Properties":{"id":"20240306205350-c6ytwv2","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240306205350-nb8sc29.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240306205351-9quppty","Type":"NodeParagraph","Properties":{"id":"20240306205351-9quppty","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"运行结果如上图，pow显示为绑定一个fn，参数为int，int，返回值为int。两个参数中间的*起分隔符的作用。"}]},{"ID":"20240306211421-0rp2blp","Type":"NodeParagraph","Properties":{"id":"20240306211421-0rp2blp","updated":"20240314112949"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"ML中函数的参数数量不可变"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240306213846-s9t0yg5","Type":"NodeParagraph","Properties":{"id":"20240306213846-s9t0yg5","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"类型检查规则：对函数的类型检查就是将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pow ：(t1 * t2 * t3...* tn) -\u0026gt; t"},{"Type":"NodeText","Data":"​添加到静态环境中。对函数体进行类型检查时，可以使用静态环境中的所有内容，包括参数t1,t2,t3，而且函数可以递归，所以可以在pow的函数体中使用pow来检查"}]},{"ID":"20240306211510-1r4sz49","Type":"NodeParagraph","Properties":{"id":"20240306211510-1r4sz49","updated":"20240314112949"},"Children":[{"Type":"NodeText","Data":"评估规则：pow就是一个val。绑定时，在动态环境中添加pow，这样之后的语句就可以使用pow了。在调用函数之前不会评估函数体。"}]},{"ID":"20240311115141-isof8co","Type":"NodeParagraph","Properties":{"id":"20240311115141-isof8co","updated":"20240314112949"}},{"ID":"20240311115141-bobnf6q","Type":"NodeParagraph","Properties":{"id":"20240311115141-bobnf6q","updated":"20240314112949"}},{"ID":"20240311115141-jwo5pqh","Type":"NodeParagraph","Properties":{"id":"20240311115141-jwo5pqh","updated":"20240314112949"}},{"ID":"20240311115141-y150gk1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240311115141-y150gk1","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"ML的pair和元组"}]},{"ID":"20240311115153-tvx4p9w","Type":"NodeParagraph","Properties":{"id":"20240311115153-tvx4p9w","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"pair语法："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(e1,e2)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311115234-73v0ub1","Type":"NodeParagraph","Properties":{"id":"20240311115234-73v0ub1","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"类型检查："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(e1的类型,e2的类型)，例：(3,4)的类型为(int*int)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311115346-ugpb6al","Type":"NodeParagraph","Properties":{"id":"20240311115346-ugpb6al","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"要取pair的值"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#1 e表示pair的第一个值，#2 e表示第二个值"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311115555-dhihgc0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311115555-dhihgc0","style":"line-height: 22px;","updated":"20240314112955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*交换*)\nfun swap (pr : int*bool) =\n    (#2 pr, #1 pr);\n\n(*pair相加*)\nfun sum_two_pairs(pr1 : int*int, pr2 : int*int) =\n    (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2);\n\n(*div和mod*)\nfun div_mod(x : int, y : int) = \n    (x div y, x mod y);\n\n(*pair排序*)\nfun sort_pair(pr : int*int) = \n    if (#1 pr) \u003e (#2 pr)\n    then (#2 pr, #1 pr)\n    else pr;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311120027-w0pm6yg","Type":"NodeParagraph","Properties":{"id":"20240311120027-w0pm6yg","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240311120027-9euyrmn.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311120029-ffka6i4","Type":"NodeParagraph","Properties":{"id":"20240311120029-ffka6i4","updated":"20240314112955"}},{"ID":"20240311144453-pgfza4x","Type":"NodeParagraph","Properties":{"id":"20240311144453-pgfza4x","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"元组就是pair的推广"}]},{"ID":"20240311144533-baalzhi","Type":"NodeParagraph","Properties":{"id":"20240311144533-baalzhi","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"元组语法："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(e1,e2,e3...en)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311144624-kavaozn","Type":"NodeParagraph","Properties":{"id":"20240311144624-kavaozn","updated":"20240314112955"},"Children":[{"Type":"NodeText","Data":"取值规则与pair一致"}]},{"ID":"20240311145736-n8hwobp","Type":"NodeParagraph","Properties":{"id":"20240311145736-n8hwobp","updated":"20240314112955"}},{"ID":"20240312094202-ao7kmvq","Type":"NodeParagraph","Properties":{"id":"20240312094202-ao7kmvq","updated":"20240314112955"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"ML的元组可以放入任何值，不论他们的类型是否相同。但元组只能放入固定数量的值，且需要在定义的时候就全部放入，因为元组不知道其他未放入元素的类型。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240312094333-uks2urb","Type":"NodeParagraph","Properties":{"id":"20240312094333-uks2urb","updated":"20240314112955"}},{"ID":"20240312094333-qvd4wot","Type":"NodeParagraph","Properties":{"id":"20240312094333-qvd4wot","updated":"20240314112955"}},{"ID":"20240312094958-934j7vk","Type":"NodeParagraph","Properties":{"id":"20240312094958-934j7vk","updated":"20240314112955"}},{"ID":"20240312094958-ac5fdpk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240312094958-ac5fdpk","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"ML的列表"}]},{"ID":"20240312095011-uinpcrf","Type":"NodeParagraph","Properties":{"id":"20240312095011-uinpcrf","updated":"20240314113001"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"text","TextMarkTextContent":"ML的列表只能放入一种类型的值，但可以放入任意数量。在定义时也不需要将元素全部写出来，因为未放入的元素类型是确定的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"}]},{"ID":"20240312095237-hbdqrkj","Type":"NodeParagraph","Properties":{"id":"20240312095237-hbdqrkj","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"构建列表："}]},{"ID":"20240312095252-ypydj67","Type":"NodeParagraph","Properties":{"id":"20240312095252-ypydj67","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[] (*空列表*)"},{"Type":"NodeText","Data":"​，类型为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a list"},{"Type":"NodeText","Data":"​，a 表示万能类型"}]},{"ID":"20240312095414-ghw7kn5","Type":"NodeParagraph","Properties":{"id":"20240312095414-ghw7kn5","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[e1,e2,e3...en]"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240312095444-gry1gg8","Type":"NodeParagraph","Properties":{"id":"20240312095444-gry1gg8","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"e1 :: [e2,e3...en]"},{"Type":"NodeText","Data":"​，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"::"},{"Type":"NodeText","Data":"​可以将某个值放入列表的第一个位置，但必须是同类型的。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"::"},{"Type":"NodeText","Data":"​可以连续使用。"}]},{"ID":"20240312103158-nle6go3","Type":"NodeParagraph","Properties":{"id":"20240312103158-nle6go3","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240312103158-omnqgn4.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240312104810-bssdkri","Type":"NodeParagraph","Properties":{"id":"20240312104810-bssdkri","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"访问列表："}]},{"ID":"20240312104815-ur0bmtv","Type":"NodeParagraph","Properties":{"id":"20240312104815-ur0bmtv","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"​在ML中是一个函数，传入一个列表，它将判断这个列表是否为空。"}]},{"ID":"20240312104916-7imwbx0","Type":"NodeParagraph","Properties":{"id":"20240312104916-7imwbx0","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hd"},{"Type":"NodeText","Data":"​函数，参数为一个列表，返回列表的第一个元素。"}]},{"ID":"20240312104945-uws6n1l","Type":"NodeParagraph","Properties":{"id":"20240312104945-uws6n1l","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tl"},{"Type":"NodeText","Data":"​函数，参数为一个列表，返回除第一个元素外的其他元素。"}]},{"ID":"20240312105318-4rs5rbc","Type":"NodeParagraph","Properties":{"id":"20240312105318-4rs5rbc","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240312105318-i4xs4tn.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240312105321-bq5sb03","Type":"NodeParagraph","Properties":{"id":"20240312105321-bq5sb03","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"ML列表的一些示例："}]},{"ID":"20240313112905-jfvicmm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240313112905-jfvicmm","style":"line-height: 22px;","updated":"20240314113001"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*列表元素相乘*)\nfun list_product (list : int list) = \n    if null list\n    then 1\n    else hd list * list_product(tl list); \n\n(*列表元素相加*)\nfun sum_list(list : int list) =\n    if null list\n    then 0\n    else hd list + sum_list(tl list);\n\n(*返回x的倒计时， eg: x=5 -\u003e [5,4,3,2,1]*)\nfun countdown(x:int) =\n    if x = 0\n    then []\n    else x :: countdown(x-1);\n\n(*两个列表合并*)\nfun append(x:int list, y:int list) =\n    if null x\n    then y\n    else hd x :: append(tl x,y);\n\n(*将二元组列表的所有数字相加*)\nfun sum_pair_list(list: (int * int) list) =\n    if null list\n    then 0\n    else #1 (hd list) + #2 (hd list) + sum_pair_list(tl list);\n\n(*返回元组列表中每个元组第一个元素所组成的列表*)\nfun firsts(list: (int * int) list) =\n    if null list\n    then []\n    else #1 (hd list) :: firsts(tl list);\n\n(*返回元组列表中每个元组第二个元素所组成的列表*)\nfun seconds(list: (int * int) list) =\n    if null list\n    then []\n    else #2 (hd list) :: seconds(tl list);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240313112906-b6tnag9","Type":"NodeParagraph","Properties":{"id":"20240313112906-b6tnag9","updated":"20240314113001"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240313112906-0f4fcpq.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240313113303-hbz9s8e","Type":"NodeParagraph","Properties":{"id":"20240313113303-hbz9s8e","updated":"20240314113001"}},{"ID":"20240314102927-s0tazdn","Type":"NodeParagraph","Properties":{"id":"20240314102927-s0tazdn","updated":"20240314113001"}},{"ID":"20240314102927-7mc8pbc","Type":"NodeParagraph","Properties":{"id":"20240314102927-7mc8pbc","updated":"20240314113001"}},{"ID":"20240314102927-zn1actu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240314102927-zn1actu","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"ML的let表达式"}]},{"ID":"20240314104559-na6k3tu","Type":"NodeParagraph","Properties":{"id":"20240314104559-na6k3tu","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"使用Let表达式来引入局部变量。"}]},{"ID":"20240314104619-2lgpmpy","Type":"NodeParagraph","Properties":{"id":"20240314104619-2lgpmpy","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"语法："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code text","TextMarkTextContent":"let"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":" x1,x2,x3...xn "},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code text","TextMarkTextContent":"in"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":" e "},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color1);"},"TextMarkType":"code text","TextMarkTextContent":"end"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color1);\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240314104958-8p56e0l","Type":"NodeParagraph","Properties":{"id":"20240314104958-8p56e0l","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"let引入的局部变量只会作用于e的范围内，不会影响函数的其他不部分。若let引入的局部变量与环境中已存在的变量相同，那么let引入的变量会shadow环境中的变量。"}]},{"ID":"20240314104708-acfld33","Type":"NodeParagraph","Properties":{"id":"20240314104708-acfld33","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"例："}]},{"ID":"20240314104759-ei8wtz4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240314104759-ei8wtz4","style":"line-height: 22px;","updated":"20240314113006"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"fun test1(z : int) =\n    let \n        val x = if z \u003e 0 then z else 34;\n        val y = x + z + 9;\n    in\n        if x \u003e y then x * 2 else y * y\n    end\n\n\nfun test2() =\n    let \n        val x = 1;\n    in \n        (let val x = 2 in x + 1 end(*这里的x被shadow，值为2*)) + (let val y = x + 2 in y + 1 end(*这里的x没有被shadow，值为1*))\n    end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240314110417-oron01f","Type":"NodeParagraph","Properties":{"id":"20240314110417-oron01f","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240314110417-tqsqt0m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240314110422-qbkhg0i","Type":"NodeParagraph","Properties":{"id":"20240314110422-qbkhg0i","updated":"20240314113006"},"Children":[{"Type":"NodeText","Data":"let语法可以在任意地方嵌套。它引入了作用域的概念，让某一个变量只在let的body中生效。"}]},{"ID":"20240314112905-a4mwspt","Type":"NodeParagraph","Properties":{"id":"20240314112905-a4mwspt","updated":"20240314113006"}},{"ID":"20240314112907-40s6l4l","Type":"NodeParagraph","Properties":{"id":"20240314112907-40s6l4l","updated":"20240314113006"}},{"ID":"20240314112907-5h6pqhm","Type":"NodeParagraph","Properties":{"id":"20240314112907-5h6pqhm","updated":"20240314113006"}},{"ID":"20240314112907-6srn2zw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240314112907-6srn2zw","updated":"20240314113008"},"Children":[{"Type":"NodeText","Data":"ML的嵌套函数"}]},{"ID":"20240314113009-0dtn3gd","Type":"NodeParagraph","Properties":{"id":"20240314113009-0dtn3gd","updated":"20240314113216"},"Children":[{"Type":"NodeText","Data":"本地函数fun1嵌套在fun2中，那么fun1只能在fun2的let表达式的较晚的绑定或Body中使用。"}]},{"ID":"20240314113216-2quwwb6","Type":"NodeParagraph","Properties":{"id":"20240314113216-2quwwb6","updated":"20240314113526"},"Children":[{"Type":"NodeText","Data":"什么时候可能会使用嵌套函数：\n1、在其他地方没有用\n2、在其他地方可能会被滥用（所以放到let表达式中限制其作用域）\n3、之后可能会被删除或修改"}]},{"ID":"20240314113626-cfgaegh","Type":"NodeParagraph","Properties":{"id":"20240314113626-cfgaegh","updated":"20240314113629"},"Children":[{"Type":"NodeText","Data":"例："}]},{"ID":"20240314113629-6rfvlwo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240314113629-6rfvlwo","style":"line-height: 22px;","updated":"20240314114145"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*初始版本*)\nfun count(from : int, to : int) =\n    if from = to\n    then from :: []\n    else from :: count(from + 1, to);\n\nfun countUp(x : int) = \n    count(1, x);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240314114153-ypp82k6","Type":"NodeParagraph","Properties":{"id":"20240314114153-ypp82k6","updated":"20240314114307"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240314114307-jepml2h.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240314114153-qudppv8","Type":"NodeParagraph","Properties":{"id":"20240314114153-qudppv8","updated":"20240314114724"},"Children":[{"Type":"NodeText","Data":"以上是正常写法，在引入当前文件时，会在静态环境中绑定count和countUp，在文件之后的位置都可以调用这两个函数。"}]},{"ID":"20240314114624-wv0qnhy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240314114624-wv0qnhy","style":"line-height: 22px;","updated":"20240314115128"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*嵌套函数版*)\nfun countUp(x : int) = \n    let\n        fun count(from : int, to : int) =\n            if from = to\n            then from :: []\n            else from :: count(from + 1, to);\n    in\n        count(1, x)\n    end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240314114626-gc908y7","Type":"NodeParagraph","Properties":{"id":"20240314114626-gc908y7","updated":"20240314114626"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240314114626-6o5hf8s.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240314114659-092wtao","Type":"NodeParagraph","Properties":{"id":"20240314114659-092wtao","updated":"20240314114851"},"Children":[{"Type":"NodeText","Data":"以上是嵌套函数写法，在引入当前文件之后，就不会看到count函数了，即使调用也会显示错误。但是countUp函数仍可以正常使用，因为我们限制了count函数的作用域，它只能在countUp函数中使用。"}]},{"ID":"20240314115107-civy1uf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240314115107-civy1uf","style":"line-height: 22px;","updated":"20240314115143"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*嵌套函数优化版*)\nfun countUp(x : int) = \n    let\n        fun count(from : int) =\n            if from = x\n            then from :: []\n            else from :: count(from + 1);\n    in\n        count(1)\n    end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240314115145-0ouyfhs","Type":"NodeParagraph","Properties":{"id":"20240314115145-0ouyfhs","updated":"20240314115358"},"Children":[{"Type":"NodeText","Data":"因为嵌套函数在外层函数的函数体内，因此可以使用外层函数环境中的变量，而在上面的例子中，count函数的to参数其实就是countUp函数的x参数，而且在递归过程中x一直没有变化。因此可以直接将count函数的to参数扔掉，使用countUp函数的x即可。"}]},{"ID":"20240318105113-4gutzqp","Type":"NodeParagraph","Properties":{"id":"20240318105113-4gutzqp"}},{"ID":"20240318105123-ijc95jb","Type":"NodeParagraph","Properties":{"id":"20240318105123-ijc95jb","updated":"20240318105123"}},{"ID":"20240318105123-q9ddv7w","Type":"NodeParagraph","Properties":{"id":"20240318105123-q9ddv7w","updated":"20240318105123"}},{"ID":"20240318105124-aj6c82u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240318105124-aj6c82u","updated":"20240318105157"},"Children":[{"Type":"NodeText","Data":"ML中let表达式在效率方面的应用"}]},{"ID":"20240318105200-k7pose3","Type":"NodeParagraph","Properties":{"id":"20240318105200-k7pose3","updated":"20240318105651"},"Children":[{"Type":"NodeText","Data":"ML语言鼓励递归函数，但在使用递归函数时，若不正确的使用，会消耗大量的时间。因此，我们需要避免重复的计算，使用let表达式可以很好的实现这个目标。"}]},{"ID":"20240318105654-5g9x6q4","Type":"NodeParagraph","Properties":{"id":"20240318105654-5g9x6q4","updated":"20240318105657"},"Children":[{"Type":"NodeText","Data":"例："}]},{"ID":"20240318105658-1z9m5iq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240318105658-1z9m5iq","style":"line-height: 22px;","updated":"20240318105846"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*升序计数*)\nfun countUp(from : int, to : int) =\n    if from = to\n    then to::[]\n    else from::countUp(from+1,to);\n\n(*倒序计数*)\nfun countDown(from : int, to : int) =\n    if from = to\n    then to::[]\n    else from::countDown(from-1,to);\n\n(*重复计算的查找最大值*)\nfun find_max_bad(l : int list) =\n     if null l\n     then 0\n     else if null(tl l)\n     then hd l\n     else if hd l \u003e find_max_bad(tl l)\n     then hd l\n     else find_max_bad(tl l);\n\n(*避免重复计算的查找最大值*)\nfun find_max_batter(l : int list) =\n    if null l\n    then 0\n    else if null(tl l)\n    then hd l\n    else\n        let \n            val v = find_max_batter(tl l)\n        in\n            if hd l \u003e v\n            then hd l\n            else v\n        end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240318110141-myuh2lc","Type":"NodeParagraph","Properties":{"id":"20240318110141-myuh2lc","updated":"20240318110141"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240318110141-e7xaxqr.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240318110142-kvq51zd","Type":"NodeParagraph","Properties":{"id":"20240318110142-kvq51zd","updated":"20240318112715"},"Children":[{"Type":"NodeText","Data":"如上，若l和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tl l"},{"Type":"NodeText","Data":"​都不为空，那么就需要比较"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hd l"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tl l"},{"Type":"NodeText","Data":"​，在find_max_bad中会在if比较中调用一次自己，若"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hd l"},{"Type":"NodeText","Data":"​较小，那么会在else中再次调用自己。"}]},{"ID":"20240318112729-18zgc4s","Type":"NodeParagraph","Properties":{"id":"20240318112729-18zgc4s","updated":"20240318112838"},"Children":[{"Type":"NodeText","Data":"考虑最坏情况，若传入的l是一个正序列表，那么使用find_max_bad时，在每次的调用中都会对"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tl l"},{"Type":"NodeText","Data":"​再使用两次调用，这是一个指数级增长的速度。因此在上图中"},{"Type":"NodeTextMark","TextMarkType":"code strong","TextMarkTextContent":"find_max_bad(countUp(1,40));"},{"Type":"NodeText","Data":"​就需要手动停止计算了，所需时间：设每次递归的时间是t，总时间为t+2t+4t+8t+16t... = (1+2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"+2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"2"},{"Type":"NodeText","Data":"+2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"3"},{"Type":"NodeText","Data":"+...+2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"40"},{"Type":"NodeText","Data":")t。\n考虑最好情况，传入的是一个倒叙列表，那么每次调用都只会调用一次自身，这是一个线性增长。"}]},{"ID":"20240318112916-sojspo4","Type":"NodeParagraph","Properties":{"id":"20240318112916-sojspo4","updated":"20240318113110"},"Children":[{"Type":"NodeText","Data":"如果使用let表达式，将递归一次后的结果存下来，那么在else分支中就可以将存下来的结果返回而不是再次调用递归。"}]},{"ID":"20240318113115-v1dghca","Type":"NodeParagraph","Properties":{"id":"20240318113115-v1dghca","updated":"20240318113200"},"Children":[{"Type":"NodeText","Data":"因此，find_max_batter无论是最好情况还是最坏情况，消耗的时间都是线性增长的。"}]},{"ID":"20240318111654-o03u9w0","Type":"NodeParagraph","Properties":{"id":"20240318111654-o03u9w0"}},{"ID":"20240320211856-sa4jp1n","Type":"NodeParagraph","Properties":{"id":"20240320211856-sa4jp1n","updated":"20240320211856"}},{"ID":"20240320211856-48lj1ci","Type":"NodeParagraph","Properties":{"id":"20240320211856-48lj1ci","updated":"20240320211856"}},{"ID":"20240320211857-puku9lq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240320211857-puku9lq","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"ML的Option"}]},{"ID":"20240320212012-cpiwe7j","Type":"NodeParagraph","Properties":{"id":"20240320212012-cpiwe7j","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"option是一个包含0个元素或1个元素的结构。它的类型T根据存放的元素而决定，没有元素时是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a option"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240321112628-i26m48j","Type":"NodeParagraph","Properties":{"id":"20240321112628-i26m48j","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"option主要用于返回0个元素或1个元素的时候，例如上面的max函数，若列表为空就返回0，其实可以使用option返回NONE。这是一种更好的风格。"}]},{"ID":"20240321113430-2qvbkns","Type":"NodeParagraph","Properties":{"id":"20240321113430-2qvbkns","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"构造option："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NONE"},{"Type":"NodeText","Data":"​表示包含0个元素的option，类似于列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SOME"},{"Type":"NodeText","Data":"​表示包含一个元素的option，类似于列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"e::[]"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240321113620-y2rkhrj","Type":"NodeParagraph","Properties":{"id":"20240321113620-y2rkhrj","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"访问："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isSome"},{"Type":"NodeText","Data":"​使用这个函数来判断option是否是空(a option -\u003e bool)。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"valOf"},{"Type":"NodeText","Data":"​使用这个函数来获取option中的元素(a option -\u003e a)，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"valOf"},{"Type":"NodeText","Data":"​不能用于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NONE"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240321114111-u3p47j9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240321114111-u3p47j9","style":"line-height: 22px;","updated":"20240321115040"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*int list -\u003e int option*)\nfun max1(l : int list) =\n    if null l\n    then NONE\n    else\n        let\n            val v = max1(tl l)\n        in\n            if isSome v andalso valOf v \u003e hd l(*v不为空且v中的值大于hd l*)\n            then v\n            else SOME(hd l)(*v是空或v中的值小于hd l，这里使用SOME是因为max1需要返回一个option*)\n        end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240321114447-kc0605g","Type":"NodeParagraph","Properties":{"id":"20240321114447-kc0605g","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240321114447-yjwntva.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240321114449-eok5b4r","Type":"NodeParagraph","Properties":{"id":"20240321114449-eok5b4r","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"进一步优化，上面的max1在每次递归后都要使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"isSome"},{"Type":"NodeText","Data":"​判断v是否为空。我们可以使用下面的max2，因为l为空的情况已经在then排除了，那么执行到else的一定是一个非空列表，那么我们直接使用一个辅助类来获取 非空列表的最大值。"}]},{"ID":"20240321114522-fbnjozz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240321114522-fbnjozz","style":"line-height: 22px;","updated":"20240321115040"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c21s"},{"Type":"NodeCodeBlockCode","Data":"(*int list -\u003e int option*)\nfun max2(l:int list)=\n    if null l\n    then NONE\n    else\n        let \n            fun max_NoEmpty(l1 : int list)=(*int list -\u003e int*)\n                if null(tl l1)\n                then hd l1\n                else\n                    let\n                        val v = max_NoEmpty(tl l1)\n                    in\n                        if v \u003e hd l1\n                        then v\n                        else hd l1\n                    end\n        in\n            SOME(max_NoEmpty l)\n        end\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240321114632-a0hwxfa","Type":"NodeParagraph","Properties":{"id":"20240321114632-a0hwxfa","updated":"20240321115040"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240321114632-ftxk4a0.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326093037-0ttihn0","Type":"NodeParagraph","Properties":{"id":"20240326093037-0ttihn0"}},{"ID":"20240326093038-48uv1pk","Type":"NodeParagraph","Properties":{"id":"20240326093038-48uv1pk","updated":"20240326093038"}},{"ID":"20240326093038-gqgy28e","Type":"NodeParagraph","Properties":{"id":"20240326093038-gqgy28e","updated":"20240326093038"}},{"ID":"20240326093038-ey7pihs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240326093038-ey7pihs","updated":"20240326093114"},"Children":[{"Type":"NodeText","Data":"ML中的与或非和比较表达式"}]},{"ID":"20240326093117-kkztskt","Type":"NodeParagraph","Properties":{"id":"20240326093117-kkztskt","updated":"20240326093152"},"Children":[{"Type":"NodeText","Data":"与："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"e1 andalso e2"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326093153-7rv6lkp","Type":"NodeParagraph","Properties":{"id":"20240326093153-7rv6lkp","updated":"20240326093217"},"Children":[{"Type":"NodeText","Data":"或："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"e1 oralso e2"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326093218-1i2lsgp","Type":"NodeParagraph","Properties":{"id":"20240326093218-1i2lsgp","updated":"20240326093229"},"Children":[{"Type":"NodeText","Data":"非："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"not e1"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326093232-lz5ooiz","Type":"NodeParagraph","Properties":{"id":"20240326093232-lz5ooiz","updated":"20240326093302"},"Children":[{"Type":"NodeText","Data":"andalso和oralso是关键字，而not是一个库函数。"}]},{"ID":"20240326093303-r1d7wff","Type":"NodeParagraph","Properties":{"id":"20240326093303-r1d7wff","updated":"20240326093333"},"Children":[{"Type":"NodeText","Data":"比较表达式："}]},{"ID":"20240326093340-cdc6z16","Type":"NodeParagraph","Properties":{"id":"20240326093340-cdc6z16","updated":"20240326093427"},"Children":[{"Type":"NodeText","Data":"等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"="},{"Type":"NodeText","Data":"​，不等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​，大于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026gt;"},{"Type":"NodeText","Data":"​，小于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;"},{"Type":"NodeText","Data":"​，大于等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026gt;="},{"Type":"NodeText","Data":"​，小于等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;="},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326093913-p0v3e0d","Type":"NodeParagraph","Properties":{"id":"20240326093913-p0v3e0d","updated":"20240326094007"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026gt; \u0026lt; \u0026gt;= \u0026lt;="},{"Type":"NodeText","Data":"​可以用于浮点数，但不能一个整数一个浮点数"}]},{"ID":"20240326094010-g1f0gva","Type":"NodeParagraph","Properties":{"id":"20240326094010-g1f0gva","updated":"20240326094336"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"= \u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​不能用于浮点数，因为容易因四舍五入产生误差。"}]},{"ID":"20240326103136-nyr6cq1","Type":"NodeParagraph","Properties":{"id":"20240326103136-nyr6cq1","updated":"20240326103136"}},{"ID":"20240326103136-5uus2z9","Type":"NodeParagraph","Properties":{"id":"20240326103136-5uus2z9","updated":"20240326103136"}},{"ID":"20240326103136-5s00705","Type":"NodeParagraph","Properties":{"id":"20240326103136-5s00705","updated":"20240326103136"}},{"ID":"20240326103137-40rfica","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240326103137-40rfica","updated":"20240401094305"},"Children":[{"Type":"NodeText","Data":"ML中的副本和引用"}]},{"ID":"20240326103216-dbsuroa","Type":"NodeParagraph","Properties":{"id":"20240326103216-dbsuroa","updated":"20240401094305"},"Children":[{"Type":"NodeText","Data":"在函数式编程中，我们无法改变已经存在的数据中的值，必须创建一个新的数据才可以。"}]},{"ID":"20240326104808-nayepnk","Type":"NodeParagraph","Properties":{"id":"20240326104808-nayepnk","updated":"20240401094305"},"Children":[{"Type":"NodeText","Data":"在其他语言中，如果将一个变量x赋值给另一个变量y，需要分清是引用还是副本。如果是引用，那么修改其中一个变量，将引起另一个变量也发生变化；如果是副本，那么修改其中一个变量不会影响另一个变量。ML中不可以对已经有的数据进行更改，因此对于用户来说引用还是副本没有区别，无法修改就不会有引用的烦恼。但是使用引用仍然是一个好的风格，因为可以节省空间。"}]},{"ID":"20240326110602-2fpmua4","Type":"NodeParagraph","Properties":{"id":"20240326110602-2fpmua4","updated":"20240401094305"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240326110602-3283w2u.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240326110604-orvb66x","Type":"NodeParagraph","Properties":{"id":"20240326110604-orvb66x","updated":"20240401094305"},"Children":[{"Type":"NodeText","Data":"如上图，代码实际上是第一种引用的方式存储，但是对用户来说两种存储方式没有区别。实际上ML一直在使用引用，否则"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hd、tl"},{"Type":"NodeText","Data":"​函数的效率会大打折扣"}]}]}